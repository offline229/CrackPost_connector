<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CrackPost Visualization — Canvas High-Perf</title>

    <!-- 如果你需要完全本地化，请下载 d3.v7.min.js 到本目录并将下面这行替换成本地引用（例如 ./libs/d3.v7.min.js） -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        @font-face {
            font-family: 'zpix';
            src: url('./font/zpix.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }


        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            /* 首选本地 zpix，回退到系统字体 */
            font-family: 'zpix', 'Rajdhani', 'Roboto', sans-serif;
            width: 100vw;
            height: 100vh;
        }

        #visualization {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Canvas 覆盖在该容器内 */
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
        }

        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 180, 255, 0.2);
            border: 1px solid rgba(0, 240, 255, 0.4);
            border-radius: 4px;
            pointer-events: none;
            color: #00f7ff;
            font-size: 14px;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
            transition: all 0.12s ease;
            opacity: 0;
            z-index: 1000;
        }

        /* 复用你原来的样式（控件/标题/面板）——未变 */
        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(0, 200, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 200, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }

        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 200, 255, 0.8);
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin: 0;
            padding: 10px 20px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.3);
            background: rgba(0, 20, 40, 0.3);
            backdrop-filter: blur(5px);
            border-radius: 4px;
            z-index: 100;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 20, 40, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        /* 剩余控件样式复用（和原文件一样） */
        .time-slider {
            width: 100%;
            margin: 10px 0;
        }

        .slider-container {
            width: 100%;
            display: flex;
            align-items: center;
            margin-top: 5px;
        }

        .time-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 90%;
            height: 6px;
            background: rgba(0, 120, 180, 0.3);
            border-radius: 3px;
            outline: none;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: rgb(0, 200, 255);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
        }

        .time-display {
            color: rgba(0, 200, 255, 0.8);
            font-size: 14px;
            margin-left: 15px;
            min-width: 100px;
            text-align: left;
        }

        .button-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        .control-button {
            background: rgba(0, 100, 150, 0.4);
            border: 1px solid rgba(0, 200, 255, 0.4);
            color: rgba(0, 220, 255, 0.9);
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            outline: none;
        }

        .control-button:hover {
            background: rgba(0, 150, 200, 0.5);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
        }

        .control-button:active {
            background: rgba(0, 180, 230, 0.6);
        }

        .speed-control {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }

        .speed-label {
            color: rgba(0, 200, 255, 0.8);
            font-size: 14px;
            margin-right: 10px;
        }

        .speed-options {
            display: flex;
        }

        .speed-option {
            padding: 3px 8px;
            margin: 0 3px;
            border-radius: 3px;
            color: rgba(0, 200, 255, 0.6);
            cursor: pointer;
            font-size: 12px;
            border: 1px solid transparent;
        }

        .speed-option.active {
            border-color: rgba(0, 200, 255, 0.6);
            color: rgba(0, 220, 255, 0.9);
        }
    </style>
</head>

<body>
    <div class="grid-background"></div>
    <h1>CrackPost Visualization</h1>
    <div class="tooltip"></div>
    <div id="visualization"></div>

    <div class="controls">
        <div class="slider-container">
            <input type="range" min="0" max="100" value="100" class="time-slider" id="timeSlider">
            <div class="time-display" id="timeDisplay">All Data</div>
        </div>
        <div class="button-container">
            <button class="control-button" id="playButton">▶ Play</button>
            <button class="control-button" id="resetButton">↺ Reset</button>
        </div>
        <div class="speed-control">
            <div class="speed-label">Speed:</div>
            <div class="speed-options">
                <div class="speed-option" data-speed="0.5">0.5x</div>
                <div class="speed-option active" data-speed="1">1x</div>
                <div class="speed-option" data-speed="2">2x</div>
                <div class="speed-option" data-speed="5">5x</div>
            </div>
        </div>
    </div>

</body>

<script>

    // 待办：
    // 加入初始化进度条
    // 增加附件收纳
    // 增加每日收件数
    // b不可点击
    // 待测试里有需要改的东西

    //// ========================= 数据加载 =========================

    // 从tsv文件里读取所有需要的数据

    /**
     * 解析第一行 OC 注册数据，返回 [{name, registerDate}]
     * @param {string} ocLine - 形如 "oc_registerdata name1_2025-01-20,name2_2025-02-02"
     * @returns {Array<{name:string, registerDate:string}>}
     */
    function parseOcRegisterData(ocLine) {
        const ocMatch = (ocLine || '').match(/oc_registerdata\s+(.*)/);
        const ocData = [];
        if (!ocMatch || !ocMatch[1]) return ocData;
        const ocEntries = ocMatch[1].split(',');
        ocEntries.forEach(entry => {
            if (!entry.trim()) return;
            const [name, date] = entry.split('_');
            ocData.push({
                name: (name || '').trim(),
                registerDate: date ? date.trim() : new Date().toISOString().slice(0, 10)
            });
        });
        return ocData;
    }

    /**
     * 解析 TSV 的一行（分隔后列数组），返回 emailObj 的基本字段（不含 wordCount）
     * @param {string[]} cols - TSV 分割后的 6 列
     */
    function parseEmailRow(cols) {
        return {
            sendType: (cols[0] || '').trim(),
            date: (cols[1] || '').trim(),
            sender: (cols[2] || '').trim(),
            receiver: (cols[3] || '').trim(),
            letterType: (cols[4] || '').trim(),
            path: (cols[5] || '').trim(),
            ocNameFromContent: null,
            wordCount: 0
        };
    }

    /**
     * 给出一条存储路径，返回可尝试的 content.txt 候选列表（相对/绝对均支持）
     * @param {string} rawPath
     * @returns {string[]}
     */
    function buildContentCandidatesFromPath(rawPath) {
        if (!rawPath) return [];
        const p0 = rawPath.replace(/\\/g, '/').trim();
        let p = p0;
        if (p.indexOf('/email/') !== -1) {
            const idx = p.indexOf('/email/');
            p = '.' + p.slice(idx);
        }
        p = p.replace(/\/+$/, '');

        // ✅ 关键：在拼接路径之前就对 # 进行编码
        p = p.replace(/#/g, '%23');

        const candidates = [];
        const contentPath = `${p}/content.txt`;
        candidates.push(contentPath);
        
        return [...new Set(candidates)];
    }

    //待测试，字数
    /**
     * 读取候选路径之一的内容并计算字数，写回 emailObj.wordCount，必要时抽取发件人
     * @param {object} emailObj - emailData 中的一条记录（将被就地写 wordCount）
     * @param {string[]} candidates - 备选 content 路径
     * @param {string} sender - TSV 的 sender 字段（用于日志）
     */
    async function fetchContentAndComputeWordCount(emailObj, candidates, sender) {
        for (const cRaw of candidates) {
            try {
                
                const urlsToTry = [cRaw, encodeURI(cRaw)];
                let content = null;
                for (const url of urlsToTry) {
                    try {
                        const resp = await fetch(url);
                        if (!resp || !resp.ok) {
                            console.debug(`[wordcount] fetch 未成功: ${url} status=${resp ? resp.status : 'no-response'}`);
                            continue;
                        }
                        content = await resp.text();
                        if (!content) {
                            console.debug(`[wordcount] fetch 读取为空: ${url}`);
                            continue;
                        }
                        break;
                    } catch (e) {
                        console.debug(`[wordcount] fetch 异常: ${url} err=${e}`);
                    }
                }
                if (!content) continue;

                const norm = content
                    .replace(/\u00A0/g, ' ')
                    .replace(/\uFEFF/g, '')
                    .replace(/＝/g, '=')
                    .replace(/：/g, ':')
                    .replace(/\r/g, '')
                    .trim();

                // 尝试“----”分隔后的正文，否则回退用“发件人:xxx”后的文本
                let body = '';
                const sepMatch = norm.match(/[-]{4,}[\s\r\n]*([\s\S]*)/);
                if (sepMatch && sepMatch[1]) {
                    body = sepMatch[1];
                } else {
                    const m = norm.match(/(?:发(?:件|信)人)\s*[=:\uFF1A]?\s*[【\[]?\s*([^\]\n\r】]+?)\s*[】\]]?\s*([\s\S]*)/i);
                    if (m) {
                        emailObj.ocNameFromContent = (m[1] || '').trim();
                        body = m[2] || '';
                    } else {
                        const m2 = norm.match(/发件人[^\n\r]{0,20}[\n\r]+([\s\S]*)/i);
                        if (m2) body = m2[1] || '';
                    }
                }

                if (body) {
                    const cleaned = body.replace(/\s+/g, '');
                    emailObj.wordCount = cleaned.length;
                    if (!emailObj.ocNameFromContent) {
                        const m3 = norm.match(/(?:发(?:件|信)人)\s*[=:\uFF1A]?\s*[【\[]?\s*([^\]\n\r】]+?)\s*[】\]]?/i);
                        if (m3) emailObj.ocNameFromContent = (m3[1] || '').trim();
                    }
                    if (emailObj.ocNameFromContent && emailObj.ocNameFromContent.includes('@')) {
                        console.warn(`[wordcount] 发件人解析为邮箱：${emailObj.ocNameFromContent} 路径: ${cRaw} sender字段: ${sender}`);
                    }
                } else {
                    console.debug(`[wordcount] 未能抽取正文 body: ${cRaw} preview=${norm.slice(0, 200).replace(/\n/g, '↵')}`);
                }
                // 成功一次后终止
                break;
            } catch (e) {
                console.debug(`[wordcount] 处理候选路径异常: ${cRaw} err=${e}`);
                continue;
            }
        }
    }

    /**
     * 加载且只加载一次，从tsv中读取数据并存储为email和oc
     * 加载 TSV 并构建 ocData/emailData；异步读取 content 计算 wordCount
     */
    async function loadEmailData() {
        try {
            const response = await fetch('./email/global_result.tsv');
            const data = await response.text();
            const lines = data.trim().split('\n');

            // 解析 OC 注册
            const ocData = parseOcRegisterData(lines[0] || '');

            const emailData = [];
            const fetchTasks = [];

            for (let i = 2; i < lines.length; i++) {
                const cols = lines[i].split('\t');
                if (cols.length < 6) continue;

                const emailObj = parseEmailRow(cols);

                emailData.push(emailObj);

                if (emailObj.path) {
                    const candidates = buildContentCandidatesFromPath(emailObj.path);
                    fetchTasks.push(fetchContentAndComputeWordCount(emailObj, candidates, emailObj.sender));
                }
            }

            if (fetchTasks.length) {
                await Promise.all(fetchTasks);
                console.debug('[wordcount] 全部 content 读取任务完成');
            }
            console.log("加载数据:", ocData.length, "个OC,", emailData.length, "封邮件");
            return { ocData, emailData };
        } catch (error) {
            console.error('加载邮件数据失败:', error);
            return { ocData: [], emailData: [] };
        }
    }


    //// ========================= 数据解析 =========================
    /**
     * 根据 ocData/emailData 构建 usersData 和 lettersData 的入口
     * 生成用户列表（usersData）
     *  汇总所有 OC 和邮件中出现过的用户，记录每个用户首次出现的时间。 
     *  OC 用户会标记为 isOC: true，普通用户为 isOC: false。
     * 
     * 生成信件列表（lettersData）
     * 按业务规则，把邮件数据拆分为 A/B/C 三类信件，并补充必要的字段（如发件人、收件人、编号、类型、是否 OC 发件等）。
     * 对于 B 信，非 OC 发件人会自动推断最近的 OC 作为收件人。
     */
    function processEmailData(ocData, emailData) {
        const ocNames = ocData.map(oc => oc.name);

        /**
         * 汇总用户首次出现时间，生成 usersData（包含 OC + 非OC）
         */
        function buildUsersData() {
            const userFirstSeen = new Map();
            emailData.forEach(email => {
                if (!userFirstSeen.has(email.sender) || new Date(email.date) < new Date(userFirstSeen.get(email.sender))) {
                    userFirstSeen.set(email.sender, email.date);
                }
                if (email.receiver && (!userFirstSeen.has(email.receiver) || new Date(email.date) < new Date(userFirstSeen.get(email.receiver)))) {
                    userFirstSeen.set(email.receiver, email.date);
                }
            });

            const usersData = [];
            ocData.forEach(oc => {
                usersData.push({
                    name: oc.name,
                    email: `${oc.name}@example.com`,
                    registerDate: oc.registerDate,
                    isOC: true
                });
            });
            userFirstSeen.forEach((firstSeenDate, userName) => {
                if (!ocNames.includes(userName) && userName) {
                    usersData.push({
                        name: userName,
                        email: `${userName}@example.com`,
                        registerDate: firstSeenDate,
                        isOC: false
                    });
                }
            });
            return usersData;
        }

        /**
         * 辅助：找到给定日期之前最近的若干 OC（用于 B 信推断），待测试，b发给所有ic
         */
        function findRelevantOCs(date, ocHistory) {
            const emailDate = new Date(date);
            const relevantOCs = [];
            for (let i = 0; i < ocHistory.length && relevantOCs.length < 5; i++) {
                const ocDate = new Date(ocHistory[i].date);
                if (ocDate <= emailDate && !relevantOCs.includes(ocHistory[i].sender)) {
                    relevantOCs.push(ocHistory[i].sender);
                }
            }
            return relevantOCs;
        }

        /**
         * 从 emailData 构建 lettersData（A/B/C 三类），按现有业务规则
         */
        function buildLettersData() {
            const lettersData = [];
            const ocSentHistory = [];
            emailData.forEach(email => {
                if (ocNames.includes(email.sender)) {
                    ocSentHistory.push({ sender: email.sender, date: email.date });
                }
            });
            ocSentHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

            emailData.forEach(email => {
                const letterTypeMatch = (email.letterType || '').match(/^([ABC])([^\s]*)/i);
                if (!letterTypeMatch) return;
                const letterType = letterTypeMatch[1].toUpperCase();
                const letterNumber = letterTypeMatch[0];
                const isOCSender = ocNames.includes(email.sender);

                if (isOCSender) {
                    if (letterType === 'A') {
                        if ((email.sendType || '').trim() === '收') {
                            lettersData.push({
                                sender: email.sender,
                                type: letterType,
                                number: letterNumber,
                                date: email.date,
                                receivers: [],
                                isOCSender: true,
                                path: email.path || ''
                            });
                        } else {
                            return;
                        }
                    } else if (letterType === 'B') {
                        lettersData.push({
                            sender: email.sender,
                            type: letterType,
                            number: letterNumber,
                            date: email.date,
                            receivers: [],
                            isOCSender: true,
                            isBroadcast: true,
                            path: email.path || ''
                        });
                    } else if (letterType === 'C') {
                        if (email.receiver) {
                            lettersData.push({
                                sender: email.sender,
                                type: letterType,
                                number: letterNumber,
                                date: email.date,
                                receivers: [email.receiver],
                                isOCSender: true,
                                path: email.path || ''
                            });
                        }
                    }
                } else {
                    const relevantOCs = findRelevantOCs(email.date, ocSentHistory);
                    if (letterType === 'A') {
                        lettersData.push({
                            sender: email.sender,
                            type: letterType,
                            number: letterNumber,
                            date: email.date,
                            receivers: [],
                            isOCSender: false,
                            path: email.path || ''
                        });
                    } else if (letterType === 'B') {
                        if (relevantOCs.length > 0) {
                            lettersData.push({
                                sender: email.sender,
                                type: letterType,
                                number: letterNumber,
                                date: email.date,
                                receivers: relevantOCs,
                                isOCSender: false,
                                path: email.path || ''
                            });
                        }
                    } else if (letterType === 'C') {
                        if (email.receiver) {
                            lettersData.push({
                                sender: email.sender,
                                type: letterType,
                                number: letterNumber,
                                date: email.date,
                                receivers: [email.receiver],
                                isOCSender: false,
                                path: email.path || ''
                            });
                        }
                    }
                }
            });
            return lettersData;
        }

        const usersData = buildUsersData();
        const lettersData = buildLettersData();
        return { usersData, lettersData };
    }


    //// ========================= 数据呈现 =========================

    /**
     * 拆分：数据结构构建
     * 输入 ocData, emailData，输出 usersData, lettersData
     */
    function buildVisualizationData(ocData, emailData) {
        let usersData = [], lettersData = [];
        if ((ocData && ocData.length) || (emailData && emailData.length)) {
            const processed = processEmailData(ocData, emailData);
            usersData = processed.usersData;
            lettersData = processed.lettersData;
        } else {
            // fallback mock (keeps same structure)
            usersData = [
                { name: "OC1", email: "oc1@example.com", registerDate: "2025-01-01", isOC: true },
                { name: "OC2", email: "oc2@example.com", registerDate: "2025-01-05", isOC: true },
                { name: "User1", email: "user1@example.com", registerDate: "2025-01-10", isOC: false },
                { name: "User2", email: "user2@example.com", registerDate: "2025-01-15", isOC: false },
                { name: "User3", email: "user3@example.com", registerDate: "2025-01-20", isOC: false }
            ];
            lettersData = [
                { sender: "User1", type: "A", number: "A001", date: "2025-02-01", receivers: ["OC1", "OC2"], isOCSender: false },
                { sender: "OC1", type: "B", number: "B001", date: "2025-02-05", receivers: [], isOCSender: true, isBroadcast: true },
                { sender: "User2", type: "B", number: "B002", date: "2025-02-10", receivers: ["OC1"], isOCSender: false },
                { sender: "OC2", type: "C", number: "C小明", date: "2025-02-15", receivers: ["User3"], isOCSender: true },
                { sender: "User3", type: "C", number: "C002", date: "2025-02-20", receivers: ["User1"], isOCSender: false }
            ];
        }
        return { usersData, lettersData };
    }

    /**
     * 拆分：计算时间范围与初始状态
     * 输入 usersData, lettersData
     * 输出 { minDate, maxDate, currentDate, playInterval, playSpeed }
     */
    function computeTimeState(usersData, lettersData) {
        const allDates = [...usersData.map(u => u.registerDate), ...lettersData.map(l => l.date)].sort();
        const minDate = new Date(allDates[0]);
        const maxDate = new Date(allDates[allDates.length - 1]);
        let currentDate = new Date(minDate); // start from min
        let playInterval = null;
        let playSpeed = 1;
        return { minDate, maxDate, currentDate, playInterval, playSpeed };
    }


    /**
     * 拆分：画布与容器初始化
     * 返回 { container, canvas, ctx, DPR, tooltip, resizeCanvas, width, height }
     */
    function setupCanvasAndTooltip() {
        const container = document.getElementById('visualization');
        container.style.position = 'relative';
        const canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        const DPR = window.devicePixelRatio || 1;
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d', { alpha: true });

        // tooltip DOM
        const tooltip = document.querySelector('.tooltip');
        if (tooltip) {
            tooltip.style.position = 'absolute';
            tooltip.style.pointerEvents = 'none';
            tooltip.style.display = 'none';
            tooltip.style.background = 'rgba(20,20,20,0.9)';
            tooltip.style.color = '#fff';
            tooltip.style.padding = '8px 10px';
            tooltip.style.borderRadius = '6px';
            tooltip.style.fontSize = '13px';
            tooltip.style.lineHeight = '1.4';
        }

        // dimensions and time scale (will be recalculated on resize)
        let width = window.innerWidth;
        let height = window.innerHeight;
        function resizeCanvas() {
            width = Math.max(100, container.clientWidth || window.innerWidth);
            height = Math.max(100, container.clientHeight || window.innerHeight);
            canvas.width = Math.max(1, Math.floor(width * DPR));
            canvas.height = Math.max(1, Math.floor(height * DPR));
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        resizeCanvas();

        return { container, canvas, ctx, DPR, tooltip, resizeCanvas, width, height };
    }



    /**
     * 一次性布局计算（运行 force simulation 并固定节点）
     */
    function computeInitialLayout(nodes, links, timeScale, view, width, height, ticks = 300) {
        const FORCE_PARAMS = {
            charge: -30,
            linkDistance: 80,
            collideOC: 12,
            collideUser: 6,
            xStrength: 0.6,
            yStrength: 0.05
        };

        const tempLinks = links.map(l => ({ source: l.source.id, target: l.target.id }));
        const tempSim = d3.forceSimulation(nodes)
            .force("charge", d3.forceManyBody().strength(FORCE_PARAMS.charge))
            .force("x", d3.forceX(d => timeScale(new Date(d.registerDate))).strength(FORCE_PARAMS.xStrength))
            .force("y", d3.forceY(d => d.y).strength(FORCE_PARAMS.yStrength))
            .force("collision", d3.forceCollide().radius(d => d.isOC ? FORCE_PARAMS.collideOC : FORCE_PARAMS.collideUser))
            .force("link", d3.forceLink(tempLinks).id(d => d.id).distance(FORCE_PARAMS.linkDistance).strength(0));

        for (let i = 0; i < ticks; i++) tempSim.tick();
        tempSim.stop();

        // 固定所有节点位置
        nodes.forEach(n => {
            n.fx = n.x;
            n.fy = n.y;
            n.vx = 0;
            n.vy = 0;
            n._inertiaActive = false;
        });

        // 计算初始视图适配
        const prevVisible = nodes.map(n => n.visible);
        try {
            nodes.forEach(n => n.visible = true);
            view = computeFitInternal(nodes, width, height, view);
        } finally {
            nodes.forEach((n, i) => n.visible = prevVisible[i]);
        }

        return view;
    }

    /**
     * 计算视图适配（内部函数，供 computeInitialLayout 和 computeFit 调用）
     */
    function computeFitInternal(nodes, width, height, view, marginRatio = 0.08) {
        const visibleNodes = nodes.filter(n => n.visible !== false);
        const used = visibleNodes.length ? visibleNodes : nodes;
        if (!used.length) return { scale: 1, tx: 0, ty: 0 };

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        used.forEach(n => {
            if (n.x < minX) minX = n.x;
            if (n.y < minY) minY = n.y;
            if (n.x > maxX) maxX = n.x;
            if (n.y > maxY) maxY = n.y;
        });

        const bw = Math.max(1, maxX - minX);
        const bh = Math.max(1, maxY - minY);
        const marginW = width * marginRatio;
        const marginH = height * marginRatio;
        const availableW = Math.max(1, width - marginW * 2);
        const availableH = Math.max(1, height - marginH * 2);

        let scale = Math.min(availableW / bw, availableH / bh);
        scale = Math.min(scale, 1.5);
        scale = Math.max(0.02, scale);

        const bboxCx = (minX + maxX) / 2;
        const bboxCy = (minY + maxY) / 2;
        const tx = width / 2 - bboxCx * scale;
        const ty = height / 2 - bboxCy * scale;

        return { scale, tx, ty };
    }

    /**
     * 绑定所有交互事件
     */
    function setupInteractions(state) {
        const { canvas, nodes, links, view, tooltip, senderRings, nodeById,
            getDisplayPos, computeQuadraticControl, distancePointToQuadratic,
            width, height, dateState } = state;

        let draggingNode = null;
        let dragOffset = { x: 0, y: 0 };
        let panning = false;
        let panStart = null;
        let hoveredLink = null;
        let hoveredNode = null;
        let hoveredRing = null;
        let expandedItem = null;

        // 客户端坐标 -> 世界坐标
        function clientToWorld(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            const worldX = (cssX - view.tx) / view.scale;
            const worldY = (cssY - view.ty) / view.scale;
            return { worldX, worldY, cssX, cssY };
        }

        // 查找节点
        function findNodeAtWorld(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const n = nodes[i];
                if (!n.visible) continue;
                if (Math.hypot(x - n.x, y - n.y) <= n.r + 4) return n;
            }
            return null;
        }

        // 查找连线
        function findLinkAtWorld(x, y, threshold = 8 / Math.max(0.001, view.scale)) {
            for (let i = 0; i < links.length; i++) {
                const l = links[i];
                if (!l.visible) continue;
                const sPos = getDisplayPos(l.source);
                const tPos = getDisplayPos(l.target);
                const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
                const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
                const dist = distancePointToQuadratic(x, y, sx, sy, ctrl.cx, ctrl.cy, tx, ty, 30);
                if (dist <= threshold) return l;
            }
            return null;
        }

        // 查找环
        function findRingAtWorld(x, y, threshold = 6 / Math.max(0.001, view.scale)) {
            for (const sender of Object.keys(senderRings)) {
                const owner = nodeById[sender];
                if (!owner || !owner.visible) continue;
                const arr = senderRings[sender];
                for (let idx = 0; idx < arr.length; idx++) {
                    const rObj = arr[idx];
                    if (rObj.dateObj > dateState.current) continue;  
                    const rad = 12 + idx * 8;
                    const sp = getDisplayPos(owner);
                    const d = Math.hypot(x - sp.x, y - sp.y);
                    if (Math.abs(d - rad) <= threshold) {
                        return { owner, idx, rad, rObj };
                    }
                }
            }
            return null;
        }

        function showTooltipAtClient(clientX, clientY, html) {
            if (!tooltip) return;
            tooltip.innerHTML = html;
            tooltip.style.left = (clientX + 12) + 'px';
            tooltip.style.top = (clientY - 20) + 'px';
            tooltip.style.opacity = '1';
            tooltip.style.display = 'block';
        }

        function hideTooltip() {
            if (!tooltip) return;
            tooltip.style.opacity = '0';
            tooltip.style.display = 'none';
        }

        function _pushDragSample(node, x, y, t) {
            if (!node._dragSamples) node._dragSamples = [];
            node._dragSamples.push({ x, y, t });
            if (node._dragSamples.length > 6) node._dragSamples.shift();
        }

        // ===== mousemove =====
        canvas.addEventListener('mousemove', (evt) => {
            if (draggingNode) {
                const p = clientToWorld(evt.clientX, evt.clientY);
                const newFx = p.worldX - dragOffset.x;
                const newFy = p.worldY - dragOffset.y;
                draggingNode.fx = newFx;
                draggingNode.fy = newFy;
                draggingNode.x = newFx;
                draggingNode.y = newFy;
                _pushDragSample(draggingNode, newFx, newFy, Date.now());
                if (tooltip && tooltip.style.display === 'block') {
                    tooltip.style.left = (evt.clientX + 12) + 'px';
                    tooltip.style.top = (evt.clientY - 20) + 'px';
                }
                return;
            }

            if (panning && panStart) {
                const dx = evt.clientX - panStart.clientX;
                const dy = evt.clientY - panStart.clientY;
                view.tx = panStart.viewTx + dx;
                view.ty = panStart.viewTy + dy;
                return;
            }

            const p = clientToWorld(evt.clientX, evt.clientY);
            const worldX = p.worldX, worldY = p.worldY;
            const node = findNodeAtWorld(worldX, worldY);

            if (node !== hoveredNode) {
                if (expandedItem) expandedItem = null;
                hoveredNode = node;
                hoveredLink = null;
                hoveredRing = null;
                if (!node) {
                    hideTooltip();
                } else {
                    const sent = node.sentCount || 0;
                    const recv = node.recvCount || 0;
                    const sWords = node.sentWords || 0;
                    const rWords = node.recvWords || 0;
                    const aRecv = node.recvACount || 0;
                    const aWords = node.recvAWords || 0;
                    const normalRecv = Math.max(0, recv - aRecv);
                    const normalRWords = Math.max(0, rWords - aWords);
                    const html = `<b>发信人：</b>${node.displayName || node.id}` +
                        `<br><b>发出：</b>${sent}` +
                        `<br><b>发字数：</b>${sWords} 字` +
                        `<br><b>收到(总)：</b>${recv}` +
                        `<br><b>收字数(总)：</b>${rWords} 字` +
                        `<br><b>其中A：</b>${aRecv} 封 / ${aWords} 字` +
                        `<br><b>BC信：</b>${normalRecv} 封 / ${normalRWords} 字`;
                    showTooltipAtClient(evt.clientX, evt.clientY, html);
                }
            } else if (hoveredNode && tooltip && tooltip.style.display === 'block') {
                tooltip.style.left = (evt.clientX + 12) + 'px';
                tooltip.style.top = (evt.clientY - 20) + 'px';
            }

            if (!hoveredNode) {
                const link = findLinkAtWorld(worldX, worldY);
                if (link && link !== hoveredLink) {
                    if (expandedItem) expandedItem = null;
                    hoveredLink = link;
                    hoveredRing = null;
                    const letter = link.rawLetter || {};
                    const sender = link.source.id;
                    const receivers = link.target.id;
                    const number = link.number || (letter.number || '');
                    const date = link.date || (letter.date || '');
                    const type = link.type || (letter.type || '');
                    const html = `<b>发件：</b>${sender}<br><b>收件：</b>${receivers}<br><b>编号：</b>${number}<br><b>日期：</b>${date}<br><b>类型：</b>${type}`;
                    showTooltipAtClient(evt.clientX, evt.clientY, html);
                } else if (!link && hoveredLink) {
                    hoveredLink = null;
                    hideTooltip();
                } else if (hoveredLink && tooltip && tooltip.style.display === 'block') {
                    tooltip.style.left = (evt.clientX + 12) + 'px';
                    tooltip.style.top = (evt.clientY - 20) + 'px';
                }

                if (!hoveredLink && !hoveredNode) {
                    const ringHit = findRingAtWorld(worldX, worldY);
                    if (ringHit) {
                        if (expandedItem) expandedItem = null;
                        hoveredLink = null;
                        hoveredNode = null;
                        hoveredRing = ringHit;
                        const rObj = ringHit.rObj;
                        const sender = ringHit.owner.id;
                        const receivers = (rObj.letter && rObj.letter.receivers) ? rObj.letter.receivers.join(',') : '';
                        const number = (rObj.letter && rObj.letter.number) || '';
                        const date = (rObj.letter && rObj.letter.date) || rObj.dateObj.toISOString().slice(0, 10);
                        const type = 'A';
                        const html = `<b>发件：</b>${sender}<br><b>收件：</b>${receivers}<br><b>编号：</b>${number}<br><b>日期：</b>${date}<br><b>类型：</b>${type}`;
                        showTooltipAtClient(evt.clientX, evt.clientY, html);
                    } else {
                        hoveredRing = null;
                    }
                } else {
                    hoveredRing = null;
                }
            } else {
                hoveredLink = null;
                hoveredRing = null;
            }
        });

        // ===== mousedown =====
        canvas.addEventListener('mousedown', (evt) => {
            if (evt.button !== 0) return;
            const p = clientToWorld(evt.clientX, evt.clientY);
            const node = findNodeAtWorld(p.worldX, p.worldY);
            if (node) {
                draggingNode = node;
                dragOffset.x = p.worldX - node.x;
                dragOffset.y = p.worldY - node.y;
                node.fx = node.x;
                node.fy = node.y;
                node._dragSamples = [{ x: node.x, y: node.y, t: Date.now() }];
                canvas.style.cursor = 'grabbing';
            } else {
                panning = true;
                panStart = { clientX: evt.clientX, clientY: evt.clientY, viewTx: view.tx, viewTy: view.ty };
                canvas.style.cursor = 'grabbing';
            }
        });

        // ===== mouseup =====
        window.addEventListener('mouseup', (evt) => {
            if (draggingNode) {
                const samples = draggingNode._dragSamples || [];
                let vx = 0, vy = 0;
                if (samples.length >= 2) {
                    const a = samples[samples.length - 2];
                    const b = samples[samples.length - 1];
                    const dt = Math.max(1, b.t - a.t) / 1000;
                    if (dt > 0) {
                        vx = (b.x - a.x) / dt;
                        vy = (b.y - a.y) / dt;
                    }
                }
                const MAX_V = 5000;
                vx = Math.max(-MAX_V, Math.min(MAX_V, vx));
                vy = Math.max(-MAX_V, Math.min(MAX_V, vy));
                draggingNode.vx = vx;
                draggingNode.vy = vy;
                draggingNode._inertiaActive = (Math.hypot(vx, vy) > 1e-2);
                if (draggingNode._inertiaActive) {
                    draggingNode.fx = null;
                    draggingNode.fy = null;
                } else {
                    draggingNode.fx = draggingNode.x;
                    draggingNode.fy = draggingNode.y;
                }
                delete draggingNode._dragSamples;
                draggingNode = null;
                canvas.style.cursor = 'default';
            }
            if (panning) {
                panning = false;
                panStart = null;
                canvas.style.cursor = 'default';
            }
        });

        // ===== wheel =====
        canvas.addEventListener('wheel', (evt) => {
            evt.preventDefault();
            const delta = -evt.deltaY;
            const zoomFactor = Math.exp(delta * 0.0012);
            const rect = canvas.getBoundingClientRect();
            const cssX = evt.clientX - rect.left;
            const cssY = evt.clientY - rect.top;
            const wx = (cssX - view.tx) / view.scale;
            const wy = (cssY - view.ty) / view.scale;
            let newScale = view.scale * zoomFactor;
            newScale = Math.max(0.02, Math.min(4, newScale));
            view.tx = cssX - wx * newScale;
            view.ty = cssY - wy * newScale;
            view.scale = newScale;
        }, { passive: false });

        // ===== click =====
        canvas.addEventListener('click', (evt) => {
            if (hoveredLink) {
                const rawLetter = hoveredLink.rawLetter || {};
                const rawPath = rawLetter.path || hoveredLink.path || '';
                const title = `${hoveredLink.source.id} → ${hoveredLink.target.id} ${hoveredLink.number || ''}`.trim();
                const { popup, body } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
                const candidates = resolveLetterCandidates(rawPath || '');
                if (!candidates.length) {
                    body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
                    return;
                }
                body.textContent = '正在读取信件...';
                (function tryOne(i) {
                    if (i >= candidates.length) {
                        body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                        return;
                    }
                    fetch(candidates[i]).then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.text();
                    }).then(txt => {
                        body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
                    }).catch(() => tryOne(i + 1));
                })(0);
                return;
            }

            if (hoveredRing) {
                const rObj = hoveredRing.rObj || {};
                const rawLetter = rObj.letter || rObj || {};
                const rawPath = rawLetter.path || '';
                const title = `信件：${hoveredRing.owner.id} ${(rObj.dateObj ? rObj.dateObj.toISOString().slice(0, 10) : (rObj.date || ''))}`;
                const { popup, body } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
                const candidates = resolveLetterCandidates(rawPath || '');
                if (!candidates.length) {
                    body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
                    return;
                }
                body.textContent = '正在读取信件...';
                (function tryOne(i) {
                    if (i >= candidates.length) {
                        body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                        return;
                    }
                    fetch(candidates[i]).then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.text();
                    }).then(txt => {
                        body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
                    }).catch(() => tryOne(i + 1));
                })(0);
                return;
            }
        });

        // ===== dblclick =====
        canvas.addEventListener('dblclick', (evt) => {
            view = computeFitInternal(nodes, width, height, view);
        });

        // 暴露 hover 状态供外部访问
        return {
            getHoveredNode: () => hoveredNode,
            getHoveredLink: () => hoveredLink,
            getHoveredRing: () => hoveredRing
        };
    }



    //// ========================= 模块拆分：渲染与时间控制 =========================

    /**
     * 构建节点数据结构（基于 usersData、时间刻度、窗口高度等）
     * @returns {Object} { nodes, nodeById, nodeByNormName, getNodeByName, nodeJitter }
     */
    function buildNodesData(usersData, timeScale, height) {
        function nameHashToNormalized(name) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < name.length; i++) {
                h ^= name.charCodeAt(i);
                h = Math.imul(h, 16777619) >>> 0;
            }
            return (h % 1000) / 1000;
        }

        function normName(s) {
            if (!s) return '';
            return String(s)
                .replace(/[\u00A0\u200B-\u200D\u202F\u3000]/g, '')
                .replace(/\s+/g, '')
                .trim();
        }

        const nodes = usersData.map((user, i) => {
            const registerDate = new Date(user.registerDate);
            const x = timeScale(registerDate);
            const band = Math.max(40, height * 0.18);
            const normalized = nameHashToNormalized(user.name);
            const yCenter = height * 0.5;
            const y = yCenter + (normalized - 0.5) * band;
            return {
                id: user.name,
                name: user.name,
                email: user.email,
                registerDate: user.registerDate,
                registerDateObj: registerDate,
                x: x,
                y: y,
                fx: null,
                fy: null,
                type: "user",
                isOC: !!user.isOC,
                visible: false,
                r: user.isOC ? 13 : 8,
                sentCount: 0,
                recvCount: 0,
                sentWords: 0,
                recvWords: 0
            };
        });

        const nodeById = {};
        const nodeByNormName = {};
        nodes.forEach(n => {
            nodeById[n.id] = n;
            nodeByNormName[normName(n.id)] = n;
        });

        function getNodeByName(name) {
            return nodeById[name] || nodeByNormName[normName(name)];
        }

        const nodeJitter = {};
        nodes.forEach((n, i) => {
            nodeJitter[n.id] = {
                ampX: (n.isOC ? 1.6 : 2.4) + Math.random() * 1.8,
                ampY: (n.isOC ? 1.0 : 1.6) + Math.random() * 1.4,
                phase: Math.random() * Math.PI * 2,
                speed: 0.0005 + Math.random() * 0.0012
            };
            n._dx = 0;
            n._dy = 0;
        });

        return { nodes, nodeById, nodeByNormName, getNodeByName, nodeJitter };
    }

    /**
     * 构建连线数据结构（基于 lettersData 和 nodeById）
     */
    function buildLinksData(lettersData, nodeById) {
        const connectionCounts = {};
        lettersData.forEach(letter => {
            (letter.receivers || []).forEach(receiver => {
                const key = letter.sender < receiver ? `${letter.sender}|${receiver}` : `${receiver}|${letter.sender}`;
                if (!connectionCounts[key]) connectionCounts[key] = { count: 0, connections: [] };
                connectionCounts[key].count++;
                connectionCounts[key].connections.push({
                    source: letter.sender,
                    target: receiver,
                    type: letter.type,
                    number: letter.number,
                    date: letter.date,
                    dateObj: new Date(letter.date),
                    isOCSender: letter.isOCSender || false,
                    rawLetter: letter
                });
            });
        });

        const links = [];
        Object.keys(connectionCounts).forEach(key => {
            const connInfo = connectionCounts[key];
            const conns = connInfo.connections;
            const n = conns.length;
            const order = conns
                .map((c, i) => ({ idx: i, date: new Date(c.date) }))
                .sort((a, b) => a.date - b.date)
                .map(x => x.idx);
            const idxToRank = {};
            order.forEach((origIdx, rank) => { idxToRank[origIdx] = rank; });
            const center = (n - 1) / 2;
            const SPACING = 3;
            function rankToPos(rank) {
                if (rank === 0) return center;
                const k = Math.ceil(rank / 2);
                return center + (rank % 2 === 1 ? k : -k);
            }
            conns.forEach((conn, idx) => {
                const sourceNode = nodeById[conn.source];
                const targetNode = nodeById[conn.target];
                if (!sourceNode || !targetNode) return;
                const rank = (typeof idxToRank[idx] !== 'undefined') ? idxToRank[idx] : idx;
                const pos = rankToPos(rank);
                const offset = n > 1 ? (pos - center) * SPACING : 0;
                links.push({
                    source: sourceNode,
                    target: targetNode,
                    type: conn.type,
                    number: conn.number,
                    date: conn.date,
                    dateObj: conn.dateObj,
                    isOCSender: conn.isOCSender,
                    offset: offset,
                    totalConnections: n,
                    visible: false,
                    rawLetter: conn.rawLetter
                });
            });
        });

        return links;
    }

    /**
     * 构建 A 环数据（从 emailData）
     */
    function buildSenderRings(emailData) {
        function normName(s) {
            if (!s) return '';
            return String(s)
                .replace(/[\u00A0\u200B-\u200D\u202F\u3000]/g, '')
                .replace(/\s+/g, '')
                .trim();
        }

        const senderRings = {};
        const aEarliest = new Map();

        emailData.forEach(e => {
            const raw = (e.letterType || '').trim();
            const m = raw.match(/^[Aa][＊*]?\s*[-_·]?\s*(\d+)/);
            if (!m) return;
            const digits = m[1];
            const senderRaw = (e.sender || '').trim();
            if (!senderRaw) return;
            const normSender = normName(senderRaw);
            const d = new Date(e.date);
            if (isNaN(d)) return;

            const key = `${normSender}|${digits}`;
            const prev = aEarliest.get(key);
            if (!prev || d < prev.dateObj) {
                aEarliest.set(key, {
                    senderRaw,
                    normSender,
                    digits,
                    dateObj: d,
                    displayNumber: raw,
                    date: e.date,
                    path: e.path || ''
                });
            }
        });

        aEarliest.forEach(v => {
            const sKey = v.senderRaw;
            if (!senderRings[sKey]) senderRings[sKey] = [];
            senderRings[sKey].push({
                dateObj: v.dateObj,
                letter: {
                    sender: sKey,
                    type: 'A',
                    number: v.displayNumber,
                    date: v.date,
                    receivers: [],
                    path: v.path
                }
            });
        });

        Object.keys(senderRings).forEach(s => {
            senderRings[s].sort((a, b) => a.dateObj - b.dateObj);
        });

        return senderRings;
    }

    /**
     * 初始化粒子池（基于 links）
     */
    function initParticles(links) {
        const particles = [];
        const MAX_PARTICLES = 50;
        const eligible = [];
        for (let i = 0; i < links.length; i++) {
            if (links[i].type === 'B' || links[i].type === 'C') eligible.push(i);
        }
        if (eligible.length === 0) return particles;
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const li = eligible[Math.floor(Math.random() * eligible.length)];
            const l = links[li];
            particles.push({
                linkIndex: li,
                position: Math.random(),
                speed: 0.002 + Math.random() * 0.018,
                size: (l && l.type === 'C') ? (2.6 + Math.random() * 1.2) : (1.6 + Math.random() * 1.2),
                color: (l && l.isOCSender) ? 'rgba(80,170,255,0.75)' : (l && l.type === 'B' ? 'rgba(255,120,255,0.98)' : 'rgba(255,220,80,0.98)')
            });
        }
        return particles;
    }

    /**
     * 初始化脉冲环（per node）
     */
    function initPulseRings(nodes) {
        return nodes.map((n, idx) => ({
            ownerId: n.id,
            minRadius: n.isOC ? 13 : 10,
            maxRadius: n.isOC ? 33 : 30,
            currentRadius: n.isOC ? 13 : 10,
            growing: true,
            opacity: 0.12,
            speed: 0.3 + Math.random() * 0.9,
            colorH: n.isOC ? (120 + idx * 10 % 360) : (180 + idx * 5 % 360)
        }));
    }

    /**
     * 初始化星空背景
     */
    function initStars(canvas, width, height) {
        canvas._stars = [];
        for (let i = 0; i < 60; i++) {
            canvas._stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                r: Math.random() * 1.5 + 0.3,
                alpha: Math.random() * 0.5 + 0.2
            });
        }
    }

    /**
     * 更新节点统计（字数、收发件数）
     */
    function updateNodeCounters(date, nodes, emailData, ocData, nodeById, hoveredNode, tooltip) {
        function normName(s) {
            if (!s) return '';
            return String(s)
                .replace(/[\u00A0\u200B-\u200D\u202F\u3000]/g, '')
                .replace(/\s+/g, '')
                .trim();
        }

        nodes.forEach(n => {
            n.sentCount = 0; n.recvCount = 0;
            n.sentWords = 0; n.recvWords = 0;
            n.recvACount = 0; n.recvAWords = 0;
        });

        const ocNameSet = new Set(ocData.map(o => o.name));
        const allNodes = nodes.slice();

        emailData.forEach(email => {
            try {
                const eDate = new Date(email.date);
                if (isNaN(eDate) || eDate > date) return;
                const added = Number(email.wordCount || 0);
                if (!added || added <= 0) return;

                const sendType = (email.sendType || '').trim();
                const letterTypeRaw = (email.letterType || '').trim();
                const letterType = letterTypeRaw ? letterTypeRaw.charAt(0).toUpperCase() : '';
                const sender = (email.sender || '').trim();
                const receiver = (email.receiver || '').trim();
                const isOCSender = ocNameSet.has(sender);
                const sNode = nodeById[sender];
                const rNode = nodeById[receiver];

                if (sendType === '发') {
                    if (letterType === 'A') return;
                    if (letterType === 'B') {
                        if (sNode) {
                            sNode.sentWords = (sNode.sentWords || 0) + added;
                            sNode.sentCount = (sNode.sentCount || 0) + 1;
                        }
                        return;
                    }
                    if (letterType === 'C') {
                        if (sNode) {
                            sNode.sentWords = (sNode.sentWords || 0) + added;
                            sNode.sentCount = (sNode.sentCount || 0) + 1;
                        }
                        if (rNode) {
                            rNode.recvWords = (rNode.recvWords || 0) + added;
                            rNode.recvCount = (rNode.recvCount || 0) + 1;
                        }
                        return;
                    }
                    if (sNode) {
                        sNode.sentWords = (sNode.sentWords || 0) + added;
                        sNode.sentCount = (sNode.sentCount || 0) + 1;
                    }
                    return;
                }

                if (sendType === '收') {
                    if (isOCSender && letterType === 'A') {
                        if (sNode) {
                            sNode.sentWords = (sNode.sentWords || 0) + added;
                            sNode.sentCount = (sNode.sentCount || 0) + 1;
                        }
                        allNodes.forEach(n => {
                            try {
                                const regOk = n.registerDateObj && n.registerDateObj <= eDate;
                                if (regOk) {
                                    n.recvACount = (n.recvACount || 0) + 1;
                                    n.recvAWords = (n.recvAWords || 0) + added;
                                    n.recvWords = (n.recvWords || 0) + added;
                                    n.recvCount = (n.recvCount || 0) + 1;
                                }
                            } catch (e) { }
                        });
                        return;
                    }
                    if (!isOCSender && letterType === 'A') return;
                    if (isOCSender) {
                        if (sNode) {
                            sNode.sentWords = (sNode.sentWords || 0) + added;
                            sNode.sentCount = (sNode.sentCount || 0) + 1;
                        }
                        allNodes.forEach(n => {
                            try {
                                const regOk = n.registerDateObj && n.registerDateObj <= eDate;
                                if (regOk) {
                                    n.recvWords = (n.recvWords || 0) + added;
                                    n.recvCount = (n.recvCount || 0) + 1;
                                }
                            } catch (e) { }
                        });
                        return;
                    }
                    if (sNode) {
                        sNode.sentWords = (sNode.sentWords || 0) + added;
                        sNode.sentCount = (sNode.sentCount || 0) + 1;
                    }
                    if (rNode) {
                        rNode.recvWords = (rNode.recvWords || 0) + added;
                        rNode.recvCount = (rNode.recvCount || 0) + 1;
                    }
                    return;
                }

                if (sNode) {
                    sNode.sentWords = (sNode.sentWords || 0) + added;
                    sNode.sentCount = (sNode.sentCount || 0) + 1;
                }
                if (rNode) {
                    rNode.recvWords = (rNode.recvWords || 0) + added;
                    rNode.recvCount = (rNode.recvCount || 0) + 1;
                }
            } catch (e) {
                console.debug('[wordcount] accumulate err', e, email);
            }
        });

        try {
            if (hoveredNode && tooltip && tooltip.style.display === 'block') {
                const sent = hoveredNode.sentCount || 0;
                const recv = hoveredNode.recvCount || 0;
                const sWords = hoveredNode.sentWords || 0;
                const rWords = hoveredNode.recvWords || 0;
                const aRecv = hoveredNode.recvACount || 0;
                const aWords = hoveredNode.recvAWords || 0;
                const normalRecv = Math.max(0, recv - aRecv);
                const normalRWords = Math.max(0, rWords - aWords);
                tooltip.innerHTML = `<b>发信人：</b>${hoveredNode.displayName || hoveredNode.id}` +
                    `<br><b>发出：</b>${sent}` +
                    `<br><b>发字数：</b>${sWords} 字` +
                    `<br><b>收到(总)：</b>${recv}` +
                    `<br><b>收字数(总)：</b>${rWords} 字` +
                    `<br><b>其中A：</b>${aRecv} 封 / ${aWords} 字` +
                    `<br><b>BC信：</b>${normalRecv} 封 / ${normalRWords} 字`;
            }
        } catch (e) { }
    }

    /**
     * 绑定时间控制器（slider/播放按钮等）
     */
    function setupTimeControls(state) {
        const { minDate, maxDate, dateState, timeSlider, timeDisplay, playButton,
            resetButton, speedOptions, filterByDate, onTick } = state;

        let playInterval = null;
        let playSpeed = 1;

        if (timeSlider) {
            timeSlider.min = 0;
            timeSlider.max = 100;
            timeSlider.value = 0;
        }

        function updateTimeDisplay(date) {
            const d = date || dateState.current;
            if (timeDisplay) timeDisplay.textContent = d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        function setCurrentDateFromSliderValue(valuePercent) {
            const p = Math.max(0, Math.min(100, Number(valuePercent)));
            const timeRange = maxDate.getTime() - minDate.getTime();
            const newTime = minDate.getTime() + (timeRange * (p / 100));
            dateState.current = new Date(newTime);
            filterByDate(dateState.current);
            updateTimeDisplay(dateState.current);
            onTick();
        }

        if (timeSlider) {
            timeSlider.addEventListener('input', function () {
                setCurrentDateFromSliderValue(this.value);
            });
        }

        function startPlay() {
            if (playInterval) return;
            if (playButton) playButton.textContent = "⏸ Pause";
            playInterval = setInterval(() => {
                const step = 24 * 60 * 60 * 1000 * playSpeed;
                const next = new Date(dateState.current.getTime() + step);
                if (next >= maxDate) {
                    dateState.current = new Date(maxDate);
                    if (timeSlider) timeSlider.value = 100;
                    filterByDate(dateState.current);
                    updateTimeDisplay(dateState.current);
                    onTick();
                    clearInterval(playInterval);
                    playInterval = null;
                    if (playButton) playButton.textContent = "▶ Play";
                    return;
                }
                dateState.current = next;
                const percent = (dateState.current.getTime() - minDate.getTime()) / (maxDate.getTime() - minDate.getTime()) * 100;
                if (timeSlider) timeSlider.value = percent;
                filterByDate(dateState.current);
                updateTimeDisplay(dateState.current);
                onTick();
            }, 120);
        }

        function stopPlay() {
            if (!playInterval) return;
            clearInterval(playInterval);
            playInterval = null;
            if (playButton) playButton.textContent = "▶ Play";
        }

        function togglePlay() {
            if (playInterval) stopPlay();
            else startPlay();
        }

        if (playButton) playButton.addEventListener('click', togglePlay);
        if (resetButton) resetButton.addEventListener('click', () => {
            stopPlay();
            dateState.current = new Date(minDate);
            if (timeSlider) timeSlider.value = 0;
            filterByDate(dateState.current);
            updateTimeDisplay(dateState.current);
            onTick();
        });

        speedOptions.forEach(opt => {
            opt.addEventListener('click', function () {
                speedOptions.forEach(o => o.classList.remove('active'));
                this.classList.add('active');
                playSpeed = parseFloat(this.dataset.speed || '1');
                if (playInterval) {
                    stopPlay();
                    startPlay();
                }
            });
        });

        updateTimeDisplay();
        window.__setVisualizationDatePercent = setCurrentDateFromSliderValue;

        return { updateTimeDisplay, setCurrentDateFromSliderValue, stopPlay };
    }


    //// ========================= 模块拆分：渲染绘制 =========================

    /**
     * 绘制星空背景
     */
    function drawStars(ctx, canvas, DPR) {
        if (!canvas._stars) return;
        ctx.save();
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        canvas._stars.forEach(s => {
            ctx.beginPath();
            ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.restore();
    }

    /**
     * 绘制连线基础层（使用二次贝塞尔曲线）
     */
    function drawLinks(ctx, links, getDisplayPos, computeQuadraticControl) {
        ctx.save();
        ctx.lineCap = 'round';
        links.forEach(l => {
            if (!l.visible) return;
            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);

            let stroke = 'rgba(150,150,150,0.7)';
            if (l.isOCSender) {
                if (l.type === 'B') stroke = 'rgba(255,100,100,0.7)';
                if (l.type === 'C') stroke = 'rgba(100,200,255,0.85)';
            } else {
                if (l.type === 'A') stroke = 'rgba(0,255,255,0.7)';
                if (l.type === 'B') stroke = 'rgba(255,100,255,0.7)';
                if (l.type === 'C') stroke = 'rgba(80,170,255,0.75)';
            }

            ctx.beginPath();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = l.isOCSender ? (l.type === 'C' ? 2.5 : 2) : (l.type === 'C' ? 2 : 1);
            ctx.globalAlpha = 0.25;
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(ctrl.cx, ctrl.cy, tx, ty);
            ctx.stroke();

            // 绘制箭头
            drawArrowOnCurve(ctx, sx, sy, ctrl.cx, ctrl.cy, tx, ty, stroke, 0.95);
        });
        ctx.restore();
    }

    /**
     * 在二次贝塞尔曲线上绘制箭头
     */
    function drawArrowOnCurve(ctx, sx, sy, cx, cy, tx, ty, stroke, tPos = 0.95) {
        const t = Math.max(0.01, Math.min(0.99, tPos));
        const ix = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * cx + t * t * tx;
        const iy = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * cy + t * t * ty;
        const dx = 2 * (1 - t) * (cx - sx) + 2 * t * (tx - cx);
        const dy = 2 * (1 - t) * (cy - sy) + 2 * t * (ty - cy);
        const dist = Math.hypot(tx - sx, ty - sy);
        if (dist < 8) return;
        const angle = Math.atan2(dy, dx);

        const screenArrowPx = 8;
        const arrowLen = Math.max(4, screenArrowPx / Math.max(0.2, ctx._viewScale || 1));
        const arrowW = Math.max(3, arrowLen * 0.6);

        ctx.save();
        ctx.translate(ix, iy);
        ctx.rotate(angle);
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = stroke || 'rgba(255,255,255,0.95)';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-arrowLen, arrowW / 2);
        ctx.lineTo(-arrowLen, -arrowW / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    /**
     * 绘制 OC B 类广播线（固定角度，长度伸缩）
     */
    function drawBroadcastLines(ctx, lettersData, nodeById, getDisplayPos, currentDate) {
        ctx.save();
        ctx.lineWidth = 1.5;
        const nowSec = Date.now() / 1000;
        lettersData.forEach(letter => {
            if (letter.type !== "B" || !letter.isOCSender || !letter.isBroadcast) return;
            const senderNode = nodeById[letter.sender];
            if (!senderNode || !senderNode.visible) return;
            const letterDate = letter.dateObj ? letter.dateObj : new Date(letter.date);
            if (letterDate > currentDate) return;
            const sp = getDisplayPos(senderNode);

            const lineCount = 5;
            if (!letter._bcastState) {
                letter._bcastState = { angles: [], phases: [], baseLen: [], amps: [], speeds: [] };
                for (let ii = 0; ii < lineCount; ii++) {
                    letter._bcastState.angles[ii] = (2 * Math.PI * ii / lineCount) + (Math.random() - 0.5) * 0.06;
                    letter._bcastState.phases[ii] = Math.random() * Math.PI * 2;
                    letter._bcastState.baseLen[ii] = 28 + ii * 8 + Math.random() * 6;
                    letter._bcastState.amps[ii] = 6 + Math.random() * 16;
                    letter._bcastState.speeds[ii] = 0.6 + Math.random() * 1.2;
                }
            }
            const st = letter._bcastState;

            for (let i = 0; i < lineCount; i++) {
                const ang = st.angles[i];
                const len = st.baseLen[i] + st.amps[i] * (0.5 + 0.5 * Math.sin(st.phases[i] + nowSec * st.speeds[i]));
                const ex = sp.x + Math.cos(ang) * len;
                const ey = sp.y + Math.sin(ang) * len;

                const grad = ctx.createLinearGradient(sp.x, sp.y, ex, ey);
                grad.addColorStop(0.0, 'rgba(255,140,120,0.65)');
                grad.addColorStop(0.6, 'rgba(255,140,120,0.65)');
                grad.addColorStop(1.0, 'rgba(255,140,120,0.65)');

                ctx.strokeStyle = grad;
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.moveTo(sp.x, sp.y);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                ctx.fillStyle = 'rgba(255,200,180,0.65)';
                ctx.beginPath();
                ctx.arc(ex, ey, 2.2, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.restore();
    }

    /**
     * 绘制 A 环（同心圆）
     */
    function drawARings(ctx, senderRings, getNodeByName, getDisplayPos, currentDate) {
        ctx.save();
        Object.keys(senderRings).forEach(sender => {
            const owner = getNodeByName(sender);
            if (!owner || !owner.visible) return;
            const sp = getDisplayPos(owner);
            const arr = senderRings[sender];
            arr.forEach((rObj, idx) => {
                if (rObj.dateObj > currentDate) return;
                const rad = 12 + idx * 8;
                const alpha = Math.max(0.2, 0.7 - idx * 0.08);
                ctx.beginPath();
                ctx.strokeStyle = `rgba(0,255,255,${alpha})`;
                ctx.lineWidth = 1;
                ctx.globalCompositeOperation = 'lighter';
                ctx.arc(sp.x, sp.y, rad, 0, Math.PI * 2);
                ctx.stroke();
            });
        });
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
    }

    /**
     * 绘制脉冲环（动画效果）
     */
    function drawPulseRings(ctx, pulseRings, nodeById, getDisplayPos) {
        ctx.save();
        pulseRings.forEach(p => {
            const ownerNode = nodeById[p.ownerId];
            if (!ownerNode || !ownerNode.visible) return;
            const sp = getDisplayPos(ownerNode);

            if (p.growing) {
                p.currentRadius += p.speed;
                if (p.currentRadius >= p.maxRadius) { p.currentRadius = p.maxRadius; p.growing = false; }
            } else {
                p.currentRadius -= p.speed;
                if (p.currentRadius <= p.minRadius) { p.currentRadius = p.minRadius; p.growing = true; }
            }

            const fade = 0.15 - (p.currentRadius - p.minRadius) / (p.maxRadius - p.minRadius) * 0.1;
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = `hsla(${p.colorH},100%,70%,${Math.max(0.05, fade)})`;
            ctx.arc(sp.x, sp.y, p.currentRadius, 0, Math.PI * 2);
            ctx.stroke();
        });
        ctx.restore();
    }

    /**
     * 绘制粒子（沿连线运动的光点）
     */
    function drawParticles(ctx, particles, links, getDisplayPos, computeQuadraticControl) {
        ctx.save();
        particles.forEach(pr => {
            let l = links[pr.linkIndex];
            if (!l) {
                const elig = [];
                for (let ii = 0; ii < links.length; ii++) if (links[ii].type === 'B' || links[ii].type === 'C') elig.push(ii);
                if (elig.length === 0) return;
                pr.linkIndex = elig[Math.floor(Math.random() * elig.length)];
                l = links[pr.linkIndex];
            }

            pr.position += pr.speed;
            if (pr.position > 1) {
                pr.position = Math.random() * 0.12;
                const elig = [];
                for (let ii = 0; ii < links.length; ii++) if (links[ii].type === 'B' || links[ii].type === 'C') elig.push(ii);
                if (elig.length > 0) pr.linkIndex = elig[Math.floor(Math.random() * elig.length)];
                l = links[pr.linkIndex];
            }
            if (!l || !l.visible) return;

            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
            const t = Math.max(0, Math.min(1, pr.position));
            const x = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * ctrl.cx + t * t * tx;
            const y = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * ctrl.cy + t * t * ty;

            ctx.beginPath();
            ctx.fillStyle = pr.color;
            ctx.globalAlpha = 0.95;
            ctx.arc(x, y, pr.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.restore();
    }

    /**
     * 更新节点抖动偏移
     */
    function updateNodeJitter(nodes, nodeJitter) {
        const now = Date.now();
        nodes.forEach(n => {
            const j = nodeJitter[n.id];
            if (!j) { n._dx = 0; n._dy = 0; return; }
            const t = now * j.speed + j.phase;
            n._dx = Math.sin(t) * j.ampX;
            n._dy = Math.cos(t) * j.ampY;
        });
    }

    /**
     * 绘制节点
     */
    function drawNodes(ctx, nodes, getDisplayPos) {
        ctx.save();
        nodes.forEach((n, i) => {
            if (!n.visible) return;
            const d = getDisplayPos(n);

            ctx.beginPath();
            ctx.fillStyle = n.isOC ? `hsla(${120 + (i * 12) % 360},100%,60%,0.75)` : `hsla(${180 + (i * 8) % 360},100%,55%,0.6)`;
            ctx.shadowColor = 'rgba(0,255,255,0.18)';
            ctx.shadowBlur = n.isOC ? 6 : 3;
            ctx.arc(d.x, d.y, n.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            if (n.isOC) {
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.font = `${Math.max(8, Math.floor(n.r * 0.7))}px zpix, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('OC', d.x, d.y);
                ctx.restore();
            }
        });
        ctx.restore();
    }

    /**
     * 绘制高亮（hover 效果）
     */
    function drawHighlights(ctx, hoveredLink, hoveredNode, hoveredRing, getDisplayPos, computeQuadraticControl) {
        if (hoveredLink) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgba(255,255,255,0.95)';
            ctx.globalAlpha = 1;
            const l = hoveredLink;
            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(ctrl.cx, ctrl.cy, tx, ty);
            ctx.stroke();
            ctx.restore();
        }
        if (hoveredNode) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,255,0.95)';
            const pos = getDisplayPos(hoveredNode);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, hoveredNode.r + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        if (hoveredRing) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,255,0.95)';
            const ownerPos = getDisplayPos(hoveredRing.owner);
            ctx.beginPath();
            ctx.arc(ownerPos.x, ownerPos.y, hoveredRing.rad, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }

    /**
     * 更新节点惯性运动
     */
    function updateNodeInertia(nodes, dt) {
        const FRICTION = 0.85;
        const VELOCITY_EPS = 4e-3;
        nodes.forEach(n => {
            if (n._inertiaActive) {
                n.x += n.vx * dt;
                n.y += n.vy * dt;
                n.vx *= Math.pow(FRICTION, dt * 60);
                n.vy *= Math.pow(FRICTION, dt * 60);
                if (Math.hypot(n.vx, n.vy) < VELOCITY_EPS) {
                    n.vx = 0; n.vy = 0; n._inertiaActive = false;
                    n.fx = n.x;
                    n.fy = n.y;
                } else {
                    n.fx = null;
                    n.fy = null;
                }
            }
        });
    }

    /**
     * 创建主渲染函数（onTick）
     */
    function createRenderLoop(state) {
        const { canvas, ctx, DPR, view, nodes, links, lettersData, nodeById,
            senderRings, pulseRings, particles, nodeJitter, dateState, minDate,
            getDisplayPos, getNodeByName, computeQuadraticControl,
            interactionHandlers } = state;

        function onTick() {
            if (!(dateState.current instanceof Date)) dateState.current = new Date(minDate);

            // 更新可见性
            nodes.forEach(n => { n.visible = n.registerDateObj <= dateState.current; });
            links.forEach(l => {
                l.visible = (l.source.registerDateObj <= dateState.current) &&
                    (l.target.registerDateObj <= dateState.current) &&
                    (l.dateObj <= dateState.current);
            });

            // 时间差计算
            const now = Date.now();
            if (typeof onTick._lastNow === 'undefined') onTick._lastNow = now;
            const dt = Math.min(40, now - onTick._lastNow) / 1000;
            onTick._lastNow = now;

            // 更新惯性
            updateNodeInertia(nodes, dt);

            // 清空画布并设置变换
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(DPR * view.scale, 0, 0, DPR * view.scale, DPR * view.tx, DPR * view.ty);
            ctx._viewScale = view.scale; // 传给箭头绘制函数

            // 绘制各层
            drawStars(ctx, canvas, DPR);
            drawLinks(ctx, links, getDisplayPos, computeQuadraticControl);
            drawBroadcastLines(ctx, lettersData, nodeById, getDisplayPos, dateState.current);
            drawARings(ctx, senderRings, getNodeByName, getDisplayPos, dateState.current);
            drawPulseRings(ctx, pulseRings, nodeById, getDisplayPos);
            drawParticles(ctx, particles, links, getDisplayPos, computeQuadraticControl);
            updateNodeJitter(nodes, nodeJitter);
            drawNodes(ctx, nodes, getDisplayPos);

            // 绘制高亮
            const hoveredNode = interactionHandlers.getHoveredNode();
            const hoveredLink = interactionHandlers.getHoveredLink();
            const hoveredRing = interactionHandlers.getHoveredRing();
            drawHighlights(ctx, hoveredLink, hoveredNode, hoveredRing, getDisplayPos, computeQuadraticControl);
        }

        return onTick;
    }

    //// ========================= 模块拆分：辅助工具 =========================

    /**
     * HTML 转义
     */
    function escapeHtml(s) {
        if (s == null) return '';
        return String(s).replace(/[&<>"']/g, ch => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": "&#39;"
        }[ch]));
    }

    /**
     * 解析信件路径为可尝试的候选 URL 列表
     * @param {string} rawPath - 原始路径（可能是绝对路径或相对路径）
     * @returns {string[]} - 候选 URL 数组
     */
    function resolveLetterCandidates(rawPath) {
        if (!rawPath) return [];
        let p = rawPath.replace(/\\/g, '/').trim();

        // Windows 绝对路径（如 D:/ZJU/... 或 D:\ZJU\...）
        if (/^[A-Za-z]:\//.test(p)) {
            const folder = p.replace(/\/+$/, '');
            return [
                `file:///${folder.replace(/#/g, '%23')}/content.txt`,
            ];
        }

        // 项目内相对路径或以 /email/ 的路径 -> 转为相对 ./email/...
        const idx = p.indexOf('/email/');
        if (idx !== -1) {
            p = '.' + p.slice(idx);
        } else {
            const m = p.match(/.*(email\/.*)$/i);
            if (m && m[1]) p = './' + m[1];
        }
        p = p.replace(/\/+$/, '');

        // ✅ 关键：在拼接路径之前就对 # 进行编码
        p = p.replace(/#/g, '%23');

        // 只保留 content.txt
        const candidates = [];
        const contentPath = `${p}/content.txt`;
        candidates.push(contentPath);
        
        return [...new Set(candidates)];
    }
    /**
     * 初始化可拖拽信件弹窗系统
     */
    function initEmailPopupSystem() {
        const s = document.createElement('style');
        s.textContent = `
    .email-popup {
        position: fixed;
        width: 420px;
        max-width: 80vw;
        max-height: 70vh;
        background: rgba(10,10,14,0.95);
        color: #e6f9ff;
        border: 1px solid rgba(0,200,255,0.14);
        box-shadow: 0 6px 30px rgba(0,0,0,0.6);
        border-radius: 6px;
        overflow: hidden;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        font-family: inherit;
    }
    .email-popup .hdr {
        cursor: move;
        background: linear-gradient(90deg, rgba(0,120,180,0.12), rgba(0,200,255,0.06));
        padding: 8px 10px;
        display:flex;
        justify-content:space-between;
        align-items:center;
        user-select: none;
    }
    .email-popup .hdr .title { 
        font-weight:600; 
        color:#bff; 
        font-size:13px; 
        white-space:nowrap; 
        overflow:hidden; 
        text-overflow:ellipsis;
    }
    .email-popup .hdr .actions { display:flex; gap:6px; }
    .email-popup .hdr button { 
        background:transparent; 
        border:0; 
        color:#9ff; 
        cursor:pointer; 
        padding:4px; 
        font-size:14px; 
    }
    .email-popup .body { 
        padding:10px; 
        overflow:auto; 
        flex:1; 
        font-size:13px; 
        line-height:1.4; 
        white-space:pre-wrap; 
        color:#dff; 
    }
    .email-popup .foot { 
        padding:6px 8px; 
        text-align:right; 
        font-size:12px; 
        color:#99d; 
        background:rgba(0,0,0,0.04); 
    }
    `;
        document.head.appendChild(s);

        let _popupZ = 2100;
        function bringToFront(el) {
            el.style.zIndex = ++_popupZ;
        }

        window.__createEmailPopup = function (title, left, top) {
            const popup = document.createElement('div');
            popup.className = 'email-popup';
            popup.style.left = (left || (window.innerWidth / 2 - 210)) + 'px';
            popup.style.top = (top || (window.innerHeight / 2 - 140)) + 'px';
            popup.style.width = '420px';
            popup.innerHTML = `
            <div class="hdr">
                <div class="title">${escapeHtml(title || '信件详情')}</div>
                <div class="actions">
                    <button class="btn-close" title="关闭">✕</button>
                </div>
            </div>
            <div class="body">加载中...</div>
            <div class="foot"><small>可拖拽，右上关闭</small></div>
        `;
            document.body.appendChild(popup);
            bringToFront(popup);

            const hdr = popup.querySelector('.hdr');
            const body = popup.querySelector('.body');
            const closeBtn = popup.querySelector('.btn-close');

            let dragging = false, dx = 0, dy = 0;
            hdr.addEventListener('mousedown', (e) => {
                dragging = true;
                bringToFront(popup);
                const rect = popup.getBoundingClientRect();
                dx = e.clientX - rect.left;
                dy = e.clientY - rect.top;
                document.addEventListener('mousemove', _onmove);
                document.addEventListener('mouseup', _onup);
                e.preventDefault();
            });
            function _onmove(ev) {
                if (!dragging) return;
                popup.style.left = (ev.clientX - dx) + 'px';
                popup.style.top = (ev.clientY - dy) + 'px';
            }
            function _onup() {
                dragging = false;
                document.removeEventListener('mousemove', _onmove);
                document.removeEventListener('mouseup', _onup);
            }

            popup.addEventListener('mousedown', () => bringToFront(popup));
            closeBtn.addEventListener('click', () => popup.remove());

            return {
                popup,
                body,
                setTitle: t => popup.querySelector('.title').textContent = t,
                close: () => popup.remove()
            };
        };
    }

    /**
     * 绑定点击事件处理（打开信件详情弹窗）
     */
    function setupClickHandlers(canvas, interactionHandlers) {
        canvas.addEventListener('click', (evt) => {
            const hoveredLink = interactionHandlers.getHoveredLink();
            const hoveredRing = interactionHandlers.getHoveredRing();

            if (hoveredLink) {
                const rawLetter = hoveredLink.rawLetter || {};
                const rawPath = rawLetter.path || hoveredLink.path || '';
                const title = `${hoveredLink.source.id} → ${hoveredLink.target.id} ${hoveredLink.number || ''}`.trim();
                const { popup, body } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
                const candidates = resolveLetterCandidates(rawPath || '');
                if (!candidates.length) {
                    body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
                    return;
                }
                body.textContent = '正在读取信件...';
                (function tryOne(i) {
                    if (i >= candidates.length) {
                        body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                        return;
                    }
                    fetch(candidates[i]).then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.text();
                    }).then(txt => {
                        body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
                    }).catch(() => tryOne(i + 1));
                })(0);
                return;
            }

            if (hoveredRing) {
                const rObj = hoveredRing.rObj || {};
                const rawLetter = rObj.letter || rObj || {};
                const rawPath = rawLetter.path || '';
                const title = `信件：${hoveredRing.owner.id} ${(rObj.dateObj ? rObj.dateObj.toISOString().slice(0, 10) : (rObj.date || ''))}`;
                const { popup, body } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
                const candidates = resolveLetterCandidates(rawPath || '');
                if (!candidates.length) {
                    body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
                    return;
                }
                body.textContent = '正在读取信件...';
                (function tryOne(i) {
                    if (i >= candidates.length) {
                        body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                        return;
                    }
                    fetch(candidates[i]).then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.text();
                    }).then(txt => {
                        body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
                    }).catch(() => tryOne(i + 1));
                })(0);
                return;
            }
        });
    }

    /**
     * 绑定其他画布事件（双击适配、滚轮缩放）
     */
    function setupCanvasEvents(canvas, nodes, view, width, height, tooltip) {
        // 双击适配视图
        canvas.addEventListener('dblclick', (evt) => {
            view.scale = 1;
            view.tx = 0;
            view.ty = 0;
            const newView = computeFitInternal(nodes, width, height, view);
            view.scale = newView.scale;
            view.tx = newView.tx;
            view.ty = newView.ty;
        });

        // 滚轮缩放
        canvas.addEventListener('wheel', (evt) => {
            evt.preventDefault();
            const delta = -evt.deltaY;
            const zoomFactor = Math.exp(delta * 0.0012);
            const rect = canvas.getBoundingClientRect();
            const cssX = evt.clientX - rect.left;
            const cssY = evt.clientY - rect.top;
            const wx = (cssX - view.tx) / view.scale;
            const wy = (cssY - view.ty) / view.scale;
            let newScale = view.scale * zoomFactor;
            newScale = Math.max(0.02, Math.min(4, newScale));
            view.tx = cssX - wx * newScale;
            view.ty = cssY - wy * newScale;
            view.scale = newScale;
            if (tooltip && tooltip.style.display === 'block') {
                tooltip.style.left = (evt.clientX + 12) + 'px';
                tooltip.style.top = (evt.clientY - 20) + 'px';
            }
        }, { passive: false });
    }


    //// ========================= 模块拆分：几何计算辅助函数 =========================

    /**
     * 获取节点当前显示位置（考虑抖动偏移）
     */
    function createGetDisplayPos() {
        return function (n) {
            return { x: n.x + (n._dx || 0), y: n.y + (n._dy || 0) };
        };
    }

    /**
     * 计算二次贝塞尔曲线的控制点（多连线交替分布）
     */
    function createComputeQuadraticControl() {
        return function (sourceX, sourceY, targetX, targetY, total, offset) {
            const center = (total - 1) / 2;
            const idx = offset ? (offset / 3 + center) : 0;
            const delta = idx - center;
            const BASE_CURVE = 20;
            const magnitude = Math.abs(delta) + 0.5;
            const sign = (Math.round(Math.abs(delta)) % 2 === 0) ? 1 : -1;
            const curve = BASE_CURVE * magnitude * sign;

            const dx = targetX - sourceX;
            const dy = targetY - sourceY;
            const len = Math.hypot(dx, dy) || 1;
            const cx = (sourceX + targetX) / 2 + curve * (dy) / len;
            const cy = (sourceY + targetY) / 2 - curve * (dx) / len;
            return { cx, cy };
        };
    }

    /**
     * 计算点到二次贝塞尔曲线的最短距离
     */
    function createDistancePointToQuadratic() {
        return function (px, py, x0, y0, cx, cy, x1, y1, steps = 28) {
            let minDist = Infinity;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const ix = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * cx + t * t * x1;
                const iy = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * cy + t * t * y1;
                const d = Math.hypot(px - ix, py - iy);
                if (d < minDist) minDist = d;
            }
            return minDist;
        };
    }

    /**
     * 创建初始视图状态
     */
    function createInitialView() {
        return { scale: 1, tx: 0, ty: 0 };
    }

    /**
     * 绑定窗口 resize 事件
     */
    function setupResizeHandler(resizeCanvas, timeScale, nodes, links, view, width, height) {
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (typeof timeScale !== 'undefined' && timeScale.range) {
                timeScale.range([width() * 0.1, width() * 0.9]);
            }
            const newView = computeInitialLayout(nodes, links, timeScale, view, width(), height(), 300);
            view.scale = newView.scale;
            view.tx = newView.tx;
            view.ty = newView.ty;
        });
    }

    /**
     * 初始化时间过滤函数
     */
    function createFilterByDate(nodes, links, emailData, ocData, nodeById, getHoveredNode, tooltip) {
        return function (date) {
            nodes.forEach(n => n.visible = n.registerDateObj <= date);
            links.forEach(link => {
                const sourceVisible = link.source && link.source.registerDateObj && link.source.registerDateObj <= date;
                const targetVisible = link.target && link.target.registerDateObj && link.target.registerDateObj <= date;
                link.visible = sourceVisible && targetVisible && link.dateObj <= date;
            });
            const hoveredNode = getHoveredNode ? getHoveredNode() : null;
            updateNodeCounters(date, nodes, emailData, ocData, nodeById, hoveredNode, tooltip);
        };
    }


    async function initVisualization() {
        // 1. 加载数据
        const { ocData, emailData } = await loadEmailData();
        const { usersData, lettersData } = buildVisualizationData(ocData, emailData);

        // 2. 计算时间范围
        let { minDate, maxDate, playInterval, playSpeed } = computeTimeState(usersData, lettersData);
        const dateState = { current: new Date(minDate) };

        // 3. 初始化画布
        const { container, canvas, ctx, DPR, tooltip, resizeCanvas, width, height } = setupCanvasAndTooltip();

        // 4. 构建时间刻度
        const dateExtent = d3.extent(usersData, d => new Date(d.registerDate));
        const timeScale = d3.scaleTime().domain(dateExtent).range([width * 0.1, width * 0.9]);

        // 5. 构建数据结构
        const { nodes, nodeById, nodeByNormName, getNodeByName, nodeJitter } = buildNodesData(usersData, timeScale, height);
        const links = buildLinksData(lettersData, nodeById);
        const senderRings = buildSenderRings(emailData);
        const particles = initParticles(links);
        const pulseRings = initPulseRings(nodes);
        initStars(canvas, width, height);

        // 6. 创建辅助函数与初始视图
        const getDisplayPos = createGetDisplayPos();
        const computeQuadraticControl = createComputeQuadraticControl();
        const distancePointToQuadratic = createDistancePointToQuadratic();
        let view = createInitialView();
        view = computeInitialLayout(nodes, links, timeScale, view, width, height, 300);

        // 7. 绑定交互
        const interactionState = { canvas, nodes, links, view, tooltip, senderRings, nodeById, getDisplayPos, computeQuadraticControl, distancePointToQuadratic, width, height, dateState };
        const interactionHandlers = setupInteractions(interactionState);

        // 8. 启动渲染
        const renderState = { canvas, ctx, DPR, view, nodes, links, lettersData, nodeById, senderRings, pulseRings, particles, nodeJitter, dateState, minDate, getDisplayPos, getNodeByName, computeQuadraticControl, interactionHandlers };
        const onTick = createRenderLoop(renderState);
        function continuousRender() { onTick(); requestAnimationFrame(continuousRender); }
        continuousRender();

        // 9. 初始化弹窗与事件
        initEmailPopupSystem();
        setupClickHandlers(canvas, interactionHandlers);
        setupCanvasEvents(canvas, nodes, view, width, height, tooltip);

        // 10. 绑定时间控制
        const timeSlider = document.getElementById('timeSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const playButton = document.getElementById('playButton');
        const resetButton = document.getElementById('resetButton');
        const speedOptions = document.querySelectorAll('.speed-option');
        const filterByDate = createFilterByDate(nodes, links, emailData, ocData, nodeById, () => interactionHandlers.getHoveredNode(), tooltip);
        const timeControlState = { minDate, maxDate, dateState, timeSlider, timeDisplay, playButton, resetButton, speedOptions, filterByDate, onTick };
        setupTimeControls(timeControlState);

        // 11. 初始化时间轴
        dateState.current = new Date(minDate);
        if (timeSlider) timeSlider.value = 0;
        filterByDate(dateState.current);
    }

    
</script>


<style>
/* Intro 覆盖层与打字动画样式（像素风冷工业版） */
#introOverlay {
  position: fixed; inset: 0;
  display: flex; align-items: center; justify-content: center;
  z-index: 4000;
  background:
    repeating-linear-gradient(0deg, rgba(20,38,56,0.35) 0 1px, transparent 1px 24px),
    repeating-linear-gradient(90deg, rgba(20,38,56,0.35) 0 1px, transparent 1px 24px),
    #0b1624; /* 深暗蓝底 */
  backdrop-filter: none;
  font-family: 'zpix', sans-serif;
  overflow: hidden;
}

#introOverlay::before { content: none !important; }

.intro-center {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 18px; text-align: center;
  width: min(720px, 92vw);
}

.intro-title {
  color: rgba(0, 200, 255, 0.8);
  text-shadow: 0 0 4px rgba(0,200,255,0.35), 0 0 8px rgba(0,200,255,0.18);
  font-weight: bold;
  font-size: 22px; /* 更大 */
}

/* 居中按钮：深色、无圆角、无高光 */
#introSelectBtn {
  display: inline-block;
  background: #102232;
  border: 1px solid #436789;
  color: #b7c7d6; font-size: 14px;
  padding: 14px 32px; border-radius: 0;
  cursor: pointer; letter-spacing: 1px;
  transition: none; box-shadow: none;
  font-family: 'zpix', sans-serif;
  font-weight: bold;
  font-size: 18px;
  border-width: 2.5px;
}
#introSelectBtn:hover { background: #132a3f; border-color: #2a4157; }

/* 方格进度条：纯方块，无圆角无高光 */
.intro-progress-wrap { display: none; width: 100%; justify-content: center; }
.intro-progress-grid {
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: 12px;
  grid-template-rows: 12px;
  gap: 4px;
  padding: 6px 8px;
  background: rgba(9,18,30,0.6);
  border: 2.5px solid #1b2a3a;
  border-radius: 0;
  box-shadow: none;
}
.intro-progress-grid .sq {
  width: 12px; height: 12px;
  border-radius: 0;
  border: 1px solid #1e2c3c;
  background: #0f1d2b;
  box-shadow: none;
  transition: none;
}
.intro-progress-grid .sq.on {
  background: #3f6385;
  border-color: #3f6385;
}

.intro-lines {
  min-height: 84px; 
  color: #9fb3c7;
  font-size: 16px; /* 稍微大一点 */
  line-height: 1.7; 
  white-space: pre-line;
  font-family: 'zpix', sans-serif;
  font-weight: bold; /* 加粗 */
}
.intro-line {
  font-weight: bold; /* 加粗 */
}
.intro-line span.char { opacity: 0; animation: fadeInChar .25s forwards; }
@keyframes fadeInChar { to { opacity: 1; } }

.fade-out { animation: fadeOutOverlay .6s forwards; }
@keyframes fadeOutOverlay { to { opacity: 0; visibility: hidden; } }
</style>

<!-- 全屏覆盖层（结构调整） -->
<div id="introOverlay">
  <div class="intro-center">
    <div class="intro-title">CrackPost Visualization</div>
    <button id="introSelectBtn">选择 email 目录</button>

    <div class="intro-progress-wrap">
      <div class="intro-progress-grid" id="introProgressGrid"></div>
    </div>

    <div class="intro-lines" id="introLines"></div>
  </div>
</div>

<script>
/* 覆盖原自动初始化：仅在引导结束后调用（脚本逻辑增强） */
window.__preloadedData = null;

(function () {
  const origFetch = window.fetch.bind(window);
  let localFilesMap = null;

  function normPath(p){return String(p||'').replace(/\\/g,'/').replace(/^\.\/+/,'').replace(/^\/+/,'').replace(/\/+/g,'/');}
  function guessContentType(p){
    p=p.toLowerCase();
    if(p.endsWith('.tsv'))return 'text/tab-separated-values; charset=utf-8';
    if(p.endsWith('.txt'))return 'text/plain; charset=utf-8';
    return 'text/plain; charset=utf-8';
  }

  // 引导界面元素
  const overlay=document.getElementById('introOverlay');
  const selectBtn=document.getElementById('introSelectBtn');
  const progressWrap=document.querySelector('.intro-progress-wrap');
  const progressGrid=document.getElementById('introProgressGrid');
  const linesBox=document.getElementById('introLines');

  const PROG_SQUARES = 20;
  function buildSquares(){
    progressGrid.innerHTML = '';
    for(let i=0;i<PROG_SQUARES;i++){
      const s=document.createElement('div');
      s.className='sq';
      progressGrid.appendChild(s);
    }
  }
  function setProgress(p){ // p: 0~1
    const squares = progressGrid.children;
    const active = Math.max(0, Math.min(PROG_SQUARES, Math.floor(PROG_SQUARES * p)));
    for(let i=0;i<squares.length;i++) squares[i].classList.toggle('on', i < active);
  }

  async function enableLocalEmailDirMode(){
    return new Promise(resolve=>{
      const input=document.createElement('input');
      input.type='file'; input.webkitdirectory=true; input.multiple=true; input.style.display='none';
      document.body.appendChild(input);
      input.addEventListener('change', async e=>{
        try{
          const files=Array.from(e.target.files||[]);
          if(!files.length){alert('未选择任何文件'); resolve(false); return;}
          const map=new Map();
          files.forEach(f=>{
            const rel=f.webkitRelativePath||f.name;
            const key=normPath(rel).toLowerCase();
            map.set(key,f);
            if(!key.startsWith('email/')) map.set(('email/'+key).toLowerCase(), f);
            else map.set(key.replace(/^email\//,''), f);
          });
          if(!map.has('email/global_result.tsv') && !map.has('global_result.tsv')){
            alert('请选择包含 email/global_result.tsv 的目录（请直接选中 email 文件夹）');
            resolve(false); return;
          }
          localFilesMap=map;

          // 拦截 fetch
          window.fetch=async function(resource,init){
            try{
              let url=typeof resource==='string'?resource:(resource&&resource.url)||'';
              let key=url.replace(/^file:\/+/, '').split('?')[0].split('#')[0];
              key=normPath(key).toLowerCase();
              if(key.startsWith('./')) key=key.slice(2);
              if(key.startsWith('.')) key=key.slice(1);
              if(key.startsWith('/')) key=key.slice(1);
              if(!key.startsWith('email/') && key.indexOf('/email/')>=0)
                key=key.slice(key.indexOf('/email/')+1);
              if(localFilesMap && localFilesMap.has(key)){
                const file=localFilesMap.get(key);
                const text=await file.text();
                return new Response(text,{status:200,headers:{'Content-Type':guessContentType(key)}});
              }
            }catch(e){ console.debug('[local-fetch fallback]', e); }
            return origFetch(resource,init);
          };

          // 预加载并启动引导
          window.loadEmailData().then(d=>{
            window.__preloadedData=d;
            startIntroTyping(d);
            resolve(true);
          }).catch(err=>{
            console.error('预加载失败', err);
            resolve(false);
          });
        }finally{ input.remove(); }
      });
      input.click();
    });
  }

  selectBtn.addEventListener('click', async()=>{ await enableLocalEmailDirMode(); });

  function formatDate(dStr){
    const d=new Date(dStr); if(isNaN(d)) return dStr;
    const y=d.getFullYear(), m=('0'+(d.getMonth()+1)).slice(-2), da=('0'+d.getDate()).slice(-2);
    return `${y}年${m}月${da}日`;
  }

  function startIntroTyping(data){
    selectBtn.style.display='none';
    progressWrap.style.display='flex';
    buildSquares();
    setProgress(0);
    linesBox.innerHTML='';

    const ocSet = new Set((data.ocData||[]).map(o => (o.name||'').trim()).filter(Boolean));
    const { usersData } = processEmailData(data.ocData || [], data.emailData || []);
    const userCount = usersData.length;
    const letterCount = (data.emailData||[]).length;
    const dates=[...(data.ocData||[]).map(o=>o.registerDate),...(data.emailData||[]).map(e=>e.date)]
      .filter(Boolean).sort();
    const minD=dates.length?dates[0]:new Date().toISOString().slice(0,10);
    const maxD=dates.length?dates[dates.length-1]:minD;

    const lines=[
      `正在检索从 ${formatDate(minD)} 到 ${formatDate(maxD)} 的通信记录`,
      `正在联系 ${userCount} 位笔友`,
      `正在邮递 ${letterCount} 封信`,
      `Crackpost可视化即将启动，请稍候...`
    ];

    // ===== 新增：时间驱动进度条（均匀推进） =====
    const charDelay = 55;       // 单字符打字延时 (ms) 可再调慢
    const linePause = 700;     // 每行完成后的停顿 (ms)
    const perLineCharCounts = lines.map(l => l.length);
    // 总时长 = Σ(字符数*charDelay) + 行间停顿(最后一行无停顿)
    const totalDuration =
      perLineCharCounts.reduce((sum,c)=>sum + c*charDelay,0) +
      linePause * (lines.length - 1);

    let typingDone = false;
    let timeDone = false;
    const startTs = performance.now();

    function progressLoop(){
      const elapsed = performance.now() - startTs;
      let p = Math.min(1, elapsed / totalDuration);
      setProgress(p);
      if(p >= 1){
        timeDone = true;
        tryFinish();
        return;
      }
      requestAnimationFrame(progressLoop);
    }
    progressLoop();

    function tryFinish(){
      if(typingDone && timeDone){
        // 与原 finishIntro 行为一致
        setTimeout(()=>{
          overlay.classList.add('fade-out');
          setTimeout(()=>{
            overlay.remove();
            if(window.__preloadedData) initVisualizationWithPreloaded(window.__preloadedData);
            else initVisualization();
          },800);
        },300);
      }
    }

    let lineIndex=0;
    function writeLine(){
      if(lineIndex>=lines.length){
        typingDone = true;
        tryFinish();
        return;
      }
      linesBox.innerHTML='';
      const text=lines[lineIndex];
      const lineDiv=document.createElement('div');
      lineDiv.className='intro-line';
      linesBox.appendChild(lineDiv);

      let ci=0;
      (function typeChar(){
        if(ci>=text.length){
          lineIndex++;
          setTimeout(writeLine, linePause);
          return;
        }
        const span=document.createElement('span');
        span.className='char';
        span.textContent=text[ci];
        lineDiv.appendChild(span);
        ci++;
        setTimeout(typeChar, charDelay);
      })();
    }
    writeLine();
  }


  // 用预加载数据初始化（原逻辑保持不变）
  function initVisualizationWithPreloaded(d){
    const { ocData,emailData }=d;
    const processed=buildVisualizationData(ocData,emailData);
    const { usersData, lettersData } = processed;
    let { minDate, maxDate } = computeTimeState(usersData, lettersData);
    const dateState={current:new Date(minDate)};
    const { container, canvas, ctx, DPR, tooltip, resizeCanvas, width, height }=setupCanvasAndTooltip();
    const dateExtent=d3.extent(usersData,d=>new Date(d.registerDate));
    const timeScale=d3.scaleTime().domain(dateExtent).range([width*0.1,width*0.9]);
    const { nodes,nodeById,getNodeByName,nodeJitter }=buildNodesData(usersData,timeScale,height);
    const links=buildLinksData(lettersData,nodeById);
    const senderRings=buildSenderRings(emailData);
    const particles=initParticles(links);
    const pulseRings=initPulseRings(nodes);
    initStars(canvas,width,height);
    const getDisplayPos=createGetDisplayPos();
    const computeQuadraticControl=createComputeQuadraticControl();
    const distancePointToQuadratic=createDistancePointToQuadratic();
    let view=createInitialView();
    view=computeInitialLayout(nodes,links,timeScale,view,width,height,300);
    const interactionState={canvas,nodes,links,view,tooltip,senderRings,nodeById,getDisplayPos,computeQuadraticControl,distancePointToQuadratic,width,height,dateState};
    const interactionHandlers=setupInteractions(interactionState);
    const renderState={canvas,ctx,DPR,view,nodes,links,lettersData,nodeById,senderRings,pulseRings,particles,nodeJitter,dateState,minDate,getDisplayPos,getNodeByName,computeQuadraticControl,interactionHandlers};
    const onTick=createRenderLoop(renderState);
    (function loop(){onTick();requestAnimationFrame(loop);})();

    initEmailPopupSystem();
    setupClickHandlers(canvas,interactionHandlers);
    setupCanvasEvents(canvas,nodes,view,width,height,tooltip);

    const timeSlider=document.getElementById('timeSlider');
    const timeDisplay=document.getElementById('timeDisplay');
    const playButton=document.getElementById('playButton');
    const resetButton=document.getElementById('resetButton');
    const speedOptions=document.querySelectorAll('.speed-option');
    const filterByDate=createFilterByDate(nodes,links,emailData,ocData,nodeById,()=>interactionHandlers.getHoveredNode(),tooltip);
    setupTimeControls({minDate,maxDate,dateState,timeSlider,timeDisplay,playButton,resetButton,speedOptions,filterByDate,onTick});
    dateState.current=new Date(minDate);
    if(timeSlider) timeSlider.value=0;
    filterByDate(dateState.current);
  }

  // 禁止自动加载，等待用户选择
  document.removeEventListener('DOMContentLoaded', initVisualization);
})();
</script>


<script>
/* 在文件末尾现有 <script> 中追加以下内容 */

(function () {
    const origFetch = window.fetch.bind(window);
    let localFilesMap = null;

    function normPath(p) {
        return String(p || '')
            .replace(/\\/g, '/')
            .replace(/^\.\/+/, '')
            .replace(/^\/+/, '')
            .replace(/\/+/g, '/');
    }

    function guessContentType(p) {
        p = p.toLowerCase();
        if (p.endsWith('.tsv')) return 'text/tab-separated-values; charset=utf-8';
        if (p.endsWith('.txt')) return 'text/plain; charset=utf-8';
        return 'text/plain; charset=utf-8';
    }

    // 选择目录，构建文件映射，并拦截 fetch
    async function enableLocalEmailDirMode() {
        return new Promise((resolve) => {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            input.style.display = 'none';
            document.body.appendChild(input);

            input.addEventListener('change', async (e) => {
                try {
                    const files = Array.from(e.target.files || []);
                    if (!files.length) {
                        alert('未选择任何文件');
                        resolve(false);
                        return;
                    }
                    // 建立映射（大小写不敏感；为方便匹配，同时映射 email/ 前缀和无前缀两种）
                    const map = new Map();
                    files.forEach(f => {
                        const rel = f.webkitRelativePath || f.name;
                        const key = normPath(rel).toLowerCase();           // 如: email/收/20250101_.../content.txt 或 global_result.tsv
                        map.set(key, f);
                        if (!key.startsWith('email/')) {
                            map.set(('email/' + key).toLowerCase(), f);   // 兼容请求以 email/ 开头
                        } else {
                            map.set(key.replace(/^email\//, ''), f);      // 兼容请求不带 email/ 前缀
                        }
                    });

                    // 校验是否含 global_result.tsv
                    if (!map.has('email/global_result.tsv') && !map.has('global_result.tsv')) {
                        alert('请选择包含 email/global_result.tsv 的目录（请直接选中“email”文件夹）');
                        resolve(false);
                        return;
                    }

                    localFilesMap = map;

                    // 拦截 fetch：命中本地映射时直接返回 Response，否则走原始 fetch
                    window.fetch = async function(resource, init) {
                        try {
                            let url = (typeof resource === 'string') ? resource : (resource && resource.url) || '';
                            // 仅拦截 email 路径相关
                            let key = url;
                            // 去掉 file:// 前缀与查询串、hash
                            key = key.replace(/^file:\/+/, '');
                            key = key.split('?')[0].split('#')[0];
                            // 相对路径规范化
                            key = normPath(key).toLowerCase();
                            // 常见相对形式归一
                            if (key.startsWith('./')) key = key.slice(2);
                            if (key.startsWith('.')) key = key.slice(1);
                            if (key.startsWith('/')) key = key.slice(1);

                            // 特别照顾 ./email/... / email/... 两种
                            if (!key.startsWith('email/')) {
                                if (key.indexOf('/email/') >= 0) {
                                    key = key.slice(key.indexOf('/email/') + 1); // 去前缀变为 email/...
                                }
                            }

                            if (localFilesMap && localFilesMap.has(key)) {
                                const file = localFilesMap.get(key);
                                const text = await file.text();
                                return new Response(text, {
                                    status: 200,
                                    headers: { 'Content-Type': guessContentType(key) }
                                });
                            }
                        } catch (err) {
                            console.debug('[local-fetch] 拦截异常，回退原始 fetch', err);
                        }
                        return origFetch(resource, init);
                    };

                    // 清空已有画布，避免重复叠加
                    const viz = document.getElementById('visualization');
                    if (viz) while (viz.firstChild) viz.removeChild(viz.firstChild);
                    const tooltip = document.querySelector('.tooltip');
                    if (tooltip) { tooltip.style.display = 'none'; }

                    // 复用原有流程
                    initVisualization();
                    resolve(true);
                } catch (err) {
                    console.error('[local] 启用本地目录模式失败', err);
                    alert('启用本地目录模式失败，请查看控制台');
                    resolve(false);
                } finally {
                    input.remove();
                }
            });

            input.click();
        });
    }

    // 测试按钮（先不管位置，固定在右上角）
    const btn = document.createElement('button');
    btn.id = 'pickLocalEmailDirBtn';
    btn.textContent = '加载本地 email 目录（测试）';
    btn.style.position = 'fixed';
    btn.style.right = '12px';
    btn.style.top = '12px';
    btn.style.zIndex = '3000';
    btn.style.padding = '6px 10px';
    btn.style.background = 'rgba(0, 120, 180, 0.5)';
    btn.style.color = '#dff';
    btn.style.border = '1px solid rgba(0,200,255,0.5)';
    btn.style.borderRadius = '6px';
    btn.onclick = () => enableLocalEmailDirMode();
    document.addEventListener('DOMContentLoaded', () => document.body.appendChild(btn));
})();
</script>

</html>