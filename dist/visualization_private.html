<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CrackPost Visualization — Canvas High-Perf</title>

    <!-- 如果你需要完全本地化，请下载 d3.v7.min.js 到本目录并将下面这行替换成本地引用（例如 ./libs/d3.v7.min.js） -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        
        @font-face {
            font-family: 'zpix';
            src: url('./font/zpix.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }


        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            /* 首选本地 zpix，回退到系统字体 */
            font-family: 'zpix', 'Rajdhani', 'Roboto', sans-serif;
            width: 100vw;
            height: 100vh;
        }
        #visualization {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        /* Canvas 覆盖在该容器内 */
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
        }

        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 180, 255, 0.2);
            border: 1px solid rgba(0, 240, 255, 0.4);
            border-radius: 4px;
            pointer-events: none;
            color: #00f7ff;
            font-size: 14px;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
            transition: all 0.12s ease;
            opacity: 0;
            z-index: 1000;
        }

        /* 复用你原来的样式（控件/标题/面板）——未变 */
        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(0, 200, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 200, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }
        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 200, 255, 0.8);
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin: 0;
            padding: 10px 20px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.3);
            background: rgba(0, 20, 40, 0.3);
            backdrop-filter: blur(5px);
            border-radius: 4px;
            z-index: 100;
        }
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 20, 40, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        /* 剩余控件样式复用（和原文件一样） */
        .time-slider { width: 100%; margin: 10px 0; }
        .slider-container { width: 100%; display:flex; align-items:center; margin-top:5px; }
        .time-slider { -webkit-appearance:none; appearance:none; width:90%; height:6px; background: rgba(0,120,180,0.3); border-radius:3px; outline:none;}
        .time-slider::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:18px; height:18px; background: rgb(0,200,255); border-radius:50%; cursor:pointer; box-shadow:0 0 10px rgba(0,200,255,0.8); }
        .time-display { color: rgba(0,200,255,0.8); font-size:14px; margin-left:15px; min-width:100px; text-align:left;}
        .button-container{ display:flex; justify-content:center; margin-top:10px; }
        .control-button{ background: rgba(0,100,150,0.4); border:1px solid rgba(0,200,255,0.4); color: rgba(0,220,255,0.9); padding:8px 15px; margin:0 5px; border-radius:5px; cursor:pointer; transition:all 0.2s ease; font-family:inherit; outline:none;}
        .control-button:hover{ background: rgba(0,150,200,0.5); box-shadow: 0 0 15px rgba(0,200,255,0.5);}
        .control-button:active{ background: rgba(0,180,230,0.6);}
        .speed-control{ display:flex; align-items:center; margin-top:5px; }
        .speed-label{ color: rgba(0,200,255,0.8); font-size:14px; margin-right:10px; }
        .speed-options{ display:flex; }
        .speed-option{ padding:3px 8px; margin:0 3px; border-radius:3px; color: rgba(0,200,255,0.6); cursor:pointer; font-size:12px; border:1px solid transparent; }
        .speed-option.active{ border-color: rgba(0,200,255,0.6); color: rgba(0,220,255,0.9); }

    </style>
</head>
<body>
    <div class="grid-background"></div>
    <h1>CrackPost Visualization</h1>
    <div class="tooltip"></div>
    <div id="visualization"></div>

    <div class="controls">
        <div class="slider-container">
            <input type="range" min="0" max="100" value="100" class="time-slider" id="timeSlider">
            <div class="time-display" id="timeDisplay">All Data</div>
        </div>
        <div class="button-container">
            <button class="control-button" id="playButton">▶ Play</button>
            <button class="control-button" id="resetButton">↺ Reset</button>
        </div>
        <div class="speed-control">
            <div class="speed-label">Speed:</div>
            <div class="speed-options">
                <div class="speed-option" data-speed="0.5">0.5x</div>
                <div class="speed-option active" data-speed="1">1x</div>
                <div class="speed-option" data-speed="2">2x</div>
                <div class="speed-option" data-speed="5">5x</div>
            </div>
        </div>
    </div>
</body>
<script>

async function loadEmailData() {
    try {
        const response = await fetch('./email/global_result.tsv');
        const data = await response.text();
        const lines = data.trim().split('\n');

        const ocLine = lines[0] || '';
        const ocMatch = ocLine.match(/oc_registerdata\s+(.*)/);
        const ocData = [];

        if (ocMatch && ocMatch[1]) {
            const ocEntries = ocMatch[1].split(',');
            ocEntries.forEach(entry => {
                if (entry.trim()) {
                    const [name, date] = entry.split('_');
                    ocData.push({
                        name: name.trim(),
                        registerDate: date ? date.trim() : new Date().toISOString().slice(0, 10)
                    });
                }
            });
        }

        const emailData = [];
        for (let i = 2; i < lines.length; i++) {
            const cols = lines[i].split('\t');
            if (cols.length >= 6) {
                emailData.push({
                    sendType: cols[0].trim(),
                    date: cols[1].trim(),
                    sender: cols[2].trim(),
                    receiver: cols[3].trim(),
                    letterType: cols[4].trim(),
                    path: cols[5].trim()
                });
            }
        }

        console.log("加载数据:", ocData.length, "个OC,", emailData.length, "封邮件");
        return { ocData, emailData };
    } catch (error) {
        console.error('加载邮件数据失败:', error);
        return { ocData: [], emailData: [] };
    }
}

function processEmailData(ocData, emailData) {
    const ocNames = ocData.map(oc => oc.name);
    const userFirstSeen = new Map();

    emailData.forEach(email => {
        if (!userFirstSeen.has(email.sender) || new Date(email.date) < new Date(userFirstSeen.get(email.sender))) {
            userFirstSeen.set(email.sender, email.date);
        }
        if (email.receiver && (!userFirstSeen.has(email.receiver) || new Date(email.date) < new Date(userFirstSeen.get(email.receiver)))) {
            userFirstSeen.set(email.receiver, email.date);
        }
    });

    const usersData = [];
    ocData.forEach(oc => {
        usersData.push({
            name: oc.name,
            email: `${oc.name}@example.com`,
            registerDate: oc.registerDate,
            isOC: true
        });
    });

    userFirstSeen.forEach((firstSeenDate, userName) => {
        if (!ocNames.includes(userName) && userName) {
            usersData.push({
                name: userName,
                email: `${userName}@example.com`,
                registerDate: firstSeenDate,
                isOC: false
            });
        }
    });

    const lettersData = [];
    const ocSentHistory = [];
    emailData.forEach(email => {
        if (ocNames.includes(email.sender)) {
            ocSentHistory.push({
                sender: email.sender,
                date: email.date
            });
        }
    });
    ocSentHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

    function findRelevantOCs(date, ocHistory) {
        const emailDate = new Date(date);
        const relevantOCs = [];
        for (let i = 0; i < ocHistory.length && relevantOCs.length < 5; i++) {
            const ocDate = new Date(ocHistory[i].date);
            if (ocDate <= emailDate && !relevantOCs.includes(ocHistory[i].sender)) {
                relevantOCs.push(ocHistory[i].sender);
            }
        }
        return relevantOCs;
    }

    emailData.forEach(email => {
        const letterTypeMatch = (email.letterType || '').match(/^([ABC])([^\s]*)/i);
        if (!letterTypeMatch) return;
        const letterType = letterTypeMatch[1].toUpperCase();
        const letterNumber = letterTypeMatch[0];
        const isOCSender = ocNames.includes(email.sender);

        if (isOCSender) {
            if (letterType === 'A') {
                // 如果这是“收”记录（当前用户收到 OC 的 A 信），也应把发件人加入 lettersData（以生成 A-ring）
                if ((email.sendType || '').trim() === '收') {
                    lettersData.push({
                        sender: email.sender,
                        type: letterType,
                        number: letterNumber,
                        date: email.date,
                        receivers: [], // 对于收到的 A 信不强制记录 receivers 列表
                        isOCSender: true,
                        path: email.path || ''
                    });
                } else {
                    // 否则（OC 发出的 A 信）保持原先忽略行为
                    return;
                }
            } 
            else if (letterType === 'B') {
                lettersData.push({
                    sender: email.sender,
                    type: letterType,
                    number: letterNumber,
                    date: email.date,
                    receivers: [],
                    isOCSender: true,
                    isBroadcast: true,
                    path: email.path || ''
                });
            } else if (letterType === 'C') {
                if (email.receiver) {
                    lettersData.push({
                        sender: email.sender,
                        type: letterType,
                        number: letterNumber,
                        date: email.date,
                        receivers: [email.receiver],
                        isOCSender: true,
                        path: email.path || ''
                    });
                }
            }
        } else {
            const relevantOCs = findRelevantOCs(email.date, ocSentHistory);
            if (letterType === 'A') {
                lettersData.push({
                    sender: email.sender,
                    type: letterType,
                    number: letterNumber,
                    date: email.date,
                    receivers: [],
                    isOCSender: false,
                    path: email.path || ''
                });
            } else if (letterType === 'B') {
                if (relevantOCs.length > 0) {
                    lettersData.push({
                        sender: email.sender,
                        type: letterType,
                        number: letterNumber,
                        date: email.date,
                        receivers: relevantOCs,
                        isOCSender: false,
                        path: email.path || ''
                    });
                }
            } else if (letterType === 'C') {
                if (email.receiver) {
                    lettersData.push({
                        sender: email.sender,
                        type: letterType,
                        number: letterNumber,
                        date: email.date,
                        receivers: [email.receiver],
                        isOCSender: false,
                        path: email.path || ''
                    });
                }
            }
        }
    });

    return { usersData, lettersData };
}

async function initVisualization() {
    // hover state variables (declare early to avoid ReferenceError)
    let hoveredLink = null;
    let hoveredNode = null;
    let hoveredRing = null;

    // load and process
    const { ocData, emailData } = await loadEmailData();
    let usersData = [], lettersData = [];
    if ((ocData && ocData.length) || (emailData && emailData.length)) {
        const processed = processEmailData(ocData, emailData);
        usersData = processed.usersData;
        lettersData = processed.lettersData;
    } else {
        // fallback mock (keeps same structure)
        usersData = [
            { name: "OC1", email: "oc1@example.com", registerDate: "2025-01-01", isOC: true },
            { name: "OC2", email: "oc2@example.com", registerDate: "2025-01-05", isOC: true },
            { name: "User1", email: "user1@example.com", registerDate: "2025-01-10", isOC: false },
            { name: "User2", email: "user2@example.com", registerDate: "2025-01-15", isOC: false },
            { name: "User3", email: "user3@example.com", registerDate: "2025-01-20", isOC: false }
        ];
        lettersData = [
            { sender: "User1", type: "A", number: "A001", date: "2025-02-01", receivers: ["OC1","OC2"], isOCSender: false },
            { sender: "OC1", type: "B", number: "B001", date: "2025-02-05", receivers: [], isOCSender: true, isBroadcast: true },
            { sender: "User2", type: "B", number: "B002", date: "2025-02-10", receivers: ["OC1"], isOCSender: false },
            { sender: "OC2", type: "C", number: "C小明", date: "2025-02-15", receivers: ["User3"], isOCSender: true },
            { sender: "User3", type: "C", number: "C002", date: "2025-02-20", receivers: ["User1"], isOCSender: false }
        ];
    }

    // compute date range
    const allDates = [...usersData.map(u => u.registerDate), ...lettersData.map(l => l.date)].sort();
    const minDate = new Date(allDates[0]);
    const maxDate = new Date(allDates[allDates.length - 1]);
    let currentDate = new Date(minDate); // start from min
    let playInterval = null;
    let playSpeed = 1;

    // canvas setup
    const container = document.getElementById('visualization');
    container.style.position = 'relative';
    const canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.left = '0';
    canvas.style.top = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    const DPR = devicePixelRatio || 1;
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d', { alpha: true });

    // tooltip DOM
    const tooltip = document.querySelector('.tooltip');
    if (tooltip) {
        tooltip.style.position = 'absolute';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.background = 'rgba(20,20,20,0.9)';
        tooltip.style.color = '#fff';
        tooltip.style.padding = '8px 10px';
        tooltip.style.borderRadius = '6px';
        tooltip.style.fontSize = '13px';
        tooltip.style.lineHeight = '1.4';
    }

    // dimensions and time scale (will be recalculated on resize)
    let width = window.innerWidth;
    let height = window.innerHeight;
    function resizeCanvas() {
        width = Math.max(100, container.clientWidth || window.innerWidth);
        height = Math.max(100, container.clientHeight || window.innerHeight);
        canvas.width = Math.max(1, Math.floor(width * DPR));
        canvas.height = Math.max(1, Math.floor(height * DPR));
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
    }
    resizeCanvas();

// ...existing code...

    window.addEventListener('resize', () => {
        resizeCanvas();
        // 保持 timeScale 的像素范围与容器一致（左右 10% margin）
        if (typeof timeScale !== 'undefined' && timeScale.range) {
            timeScale.range([width * 0.1, width * 0.9]);
        }
        // 重新基于新窗口尺寸计算一次初始布局并固定位置
        computeInitialLayout(300);
        // 注意：不要在 resize 后频繁调用 computeFit()，computeInitialLayout 内已调用一次
    });

// ...existing code...

    // timeScale for X layout (map register dates to X)
    const dateExtent = d3.extent(usersData, d => new Date(d.registerDate));
    const timeScale = d3.scaleTime()
        .domain(dateExtent)
        .range([width * 0.1, width * 0.9]);

    // deterministic hash -> used to place nodes vertically in a narrow band
    function nameHashToNormalized(name) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < name.length; i++) {
            h ^= name.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
        }
        return (h % 1000) / 1000; // 0..1
    }

    // build nodes - compute x from time, compute y deterministically but constrained to a narrow vertical band
// ...existing code...
    const nodes = usersData.map((user, i) => {
        const registerDate = new Date(user.registerDate);
        const x = timeScale(registerDate);
        // compress vertical distribution into center band: +/- 9% of height by default
        const band = Math.max(40, height * 0.18); // ensure at least some pixels
        const normalized = nameHashToNormalized(user.name);
        const yCenter = height * 0.5;
        const y = yCenter + (normalized - 0.5) * band;
        return {
            id: user.name,
            name: user.name,
            email: user.email,
            registerDate: user.registerDate,
            registerDateObj: registerDate,
            x: x,
            y: y,
            fx: null,
            fy: null,
            type: "user",
            isOC: !!user.isOC,
            visible: false,
            r: user.isOC ? 13 : 8,
            // counters (will be filled by filterByDate)
            sentCount: 0,
            recvCount: 0
        };
    });
    const nodeById = {};
    nodes.forEach(n => nodeById[n.id] = n);

    // per-node jitter params: 不改变 n.x/n.y（位置固定），仅用于绘制偏移
    const nodeJitter = {};
    nodes.forEach((n, i) => {
        // 更大的震幅，更慢的速度 -> 视觉更活但不快
        nodeJitter[n.id] = {
            ampX: (n.isOC ? 1.6 : 2.4) + Math.random() * 1.8, // 增大 X 摆动幅度 px
            ampY: (n.isOC ? 1.0 : 1.6) + Math.random() * 1.4, // 增大 Y 摆动幅度 px
            phase: Math.random() * Math.PI * 2,
            speed: 0.0005 + Math.random() * 0.0012 // 更慢的震动速度
        };
        // initialize temporary offsets
        n._dx = 0;
        n._dy = 0;
    });
// ...existing code...

    // build links same as before (links are purely visual now; they won't pull nodes)
    const connectionCounts = {};
    lettersData.forEach(letter => {
        (letter.receivers || []).forEach(receiver => {
            const key = letter.sender < receiver ? `${letter.sender}|${receiver}` : `${receiver}|${letter.sender}`;
            if (!connectionCounts[key]) connectionCounts[key] = { count: 0, connections: [] };
            connectionCounts[key].count++;
            connectionCounts[key].connections.push({
                source: letter.sender,
                target: receiver,
                type: letter.type,
                number: letter.number,
                date: letter.date,
                dateObj: new Date(letter.date),
                isOCSender: letter.isOCSender || false,
                rawLetter: letter
            });
        });
    });

    const links = [];
    Object.keys(connectionCounts).forEach(key => {
        const connInfo = connectionCounts[key];
        const conns = connInfo.connections;
        const n = conns.length;
        // 按日期升序把旧邮件排到 rank=0，依次为新 -> 更大的 rank
        const order = conns
            .map((c, i) => ({ idx: i, date: new Date(c.date) }))
            .sort((a, b) => a.date - b.date)
            .map(x => x.idx);
        const idxToRank = {};
        order.forEach((origIdx, rank) => { idxToRank[origIdx] = rank; });
        const center = (n - 1) / 2;
        const SPACING = 3; // 控制弧线间距，可调
        function rankToPos(rank) {
            // rank=0 -> center (最内侧)，rank=1 -> center+1，rank=2 -> center-1，rank=3 -> center+2 ...
            if (rank === 0) return center;
            const k = Math.ceil(rank / 2);
            return center + (rank % 2 === 1 ? k : -k);
        }
        conns.forEach((conn, idx) => {
            const sourceNode = nodeById[conn.source];
            const targetNode = nodeById[conn.target];
            if (!sourceNode || !targetNode) return;
            const rank = (typeof idxToRank[idx] !== 'undefined') ? idxToRank[idx] : idx;
            const pos = rankToPos(rank);
            const offset = n > 1 ? (pos - center) * SPACING : 0;
            links.push({
                source: sourceNode,
                target: targetNode,
                type: conn.type,
                number: conn.number,
                date: conn.date,
                dateObj: conn.dateObj,
                isOCSender: conn.isOCSender,
                offset: offset,
                totalConnections: n,
                visible: false,
                rawLetter: conn.rawLetter
            });
        });
     });
    // A-rings metadata — sort them by date
    const senderRings = {};
    // 包含所有 A 类型信件（无论是否 OC 发出），只要有 sender 字段就为该 sender 生成 ring 元数据
    lettersData.filter(l => l.type === "A" && l.sender).forEach(letter => {
         const sender = letter.sender;
         const letterDate = new Date(letter.date);
         if (!senderRings[sender]) senderRings[sender] = [];
         senderRings[sender].push({ dateObj: letterDate, letter });
     });
     Object.keys(senderRings).forEach(s => {
         senderRings[s].sort((a, b) => a.dateObj - b.dateObj);
     });

    // particles pool (unchanged)
const particles = [];
(function initParticles(){
    const MAX_PARTICLES = 50; // 可调：更大则更多光点
    // 收集所有可用的 link 索引（只针对 B/C 通讯线）
    const eligible = [];
    for (let i = 0; i < links.length; i++) {
        if (links[i].type === 'B' || links[i].type === 'C') eligible.push(i);
    }
    if (eligible.length === 0) return;
    for (let i = 0; i < MAX_PARTICLES; i++) {
        const li = eligible[Math.floor(Math.random() * eligible.length)];
        const l = links[li];
        particles.push({
            linkIndex: li,
            position: Math.random(),
            speed: 0.002 + Math.random() * 0.018, // 更宽的速度分布
            size: (l && l.type === 'C') ? (2.6 + Math.random()*1.2) : (1.6 + Math.random()*1.2),
            color: (l && l.isOCSender) ? 'rgba(80,170,255,0.75)' : (l && l.type === 'B' ? 'rgba(255,120,255,0.98)' : 'rgba(255,220,80,0.98)')
        });
    }
})();
    

    // pulse rings per node (unchanged)
    const pulseRings = nodes.map((n, idx) => ({
        ownerId: n.id,
        minRadius: n.isOC ? 13 : 10,
        maxRadius: n.isOC ? 33 : 30,
        currentRadius: n.isOC ? 13 : 10,
        growing: true,
        opacity: 0.12,
        speed: 0.3 + Math.random() * 0.9,
        colorH: n.isOC ? (120 + idx * 10 % 360) : (180 + idx * 5 % 360)
    }));

    // star background
    canvas._stars = [];
    for (let i = 0; i < 60; i++) {
        canvas._stars.push({
            x: Math.random() * width,
            y: Math.random() * height,
            r: Math.random() * 1.5 + 0.3,
            alpha: Math.random() * 0.5 + 0.2
        });
    }

    // Force params (used only in initial temp layout)
    const FORCE_PARAMS = {
        charge: -30,
        linkDistance: 80,
        collideOC: 12,
        collideUser: 6,
        xStrength: 0.6,
        yStrength: 0.05 // low y strength - we already positioned y deterministically
    };

    function getDisplayPos(n) {
        return { x: n.x + (n._dx || 0), y: n.y + (n._dy || 0) };
    }

    // 为每个节点初始化速度和惯性标记（不影响已有字段）
    nodes.forEach(n => {
        n.vx = 0;
        n.vy = 0;
        n._inertiaActive = false;
    });

    // ---------------------------
    // INITIAL LAYOUT helper（替代原有一次性 tempSim 区块）：
    // - 在初始化或 resize 时运行一次临时 force 布局以稳定位置，然后把节点固定（fx/fy）
    // - 之后播放仅改变 visible，不再触发布局变化
    let view = { scale: 1, tx: 0, ty: 0 };
    // ---------------------------
    let layoutFixed = false;

    function computeInitialLayout(ticks = 300) {
        // ensure timeScale range is up to date (resize handler 保证 timeScale.range 已同步)
        const tempLinks = links.map(l => ({ source: l.source.id, target: l.target.id }));
        const tempSim = d3.forceSimulation(nodes)
            .force("charge", d3.forceManyBody().strength(FORCE_PARAMS.charge))
            .force("x", d3.forceX(d => timeScale(new Date(d.registerDate))).strength(FORCE_PARAMS.xStrength))
            .force("y", d3.forceY(d => d.y).strength(FORCE_PARAMS.yStrength))
            .force("collision", d3.forceCollide().radius(d => d.isOC ? FORCE_PARAMS.collideOC : FORCE_PARAMS.collideUser))
            // link strength 0 — 保留视觉 links 数据结构但不牵拉节点
            .force("link", d3.forceLink(tempLinks).id(d => d.id).distance(FORCE_PARAMS.linkDistance).strength(0));

        for (let i = 0; i < ticks; i++) tempSim.tick();
        tempSim.stop();

        // freeze positions so playback won't move nodes
        nodes.forEach(n => {
            n.fx = n.x;
            n.fy = n.y;
        });

        // compute view fit once (基于固定位置)
        // 问题修复：在计算 fit 时临时使用所有节点（不受当前时间线 visible 限制）
        const prevVisible = nodes.map(n => n.visible);
        try {
            nodes.forEach(n => n.visible = true);
            computeFit();
        } finally {
            // 恢复原来的 visible 状态（播放仍然由 filterByDate 控制）
            nodes.forEach((n, i) => n.visible = prevVisible[i]);
        }

        layoutFixed = true;
        // allow GC for tempSim
    }

    // We do not keep a running simulation that modifies node positions.
    // If any code references simulation, guard those calls with `if (simulation) { ... }`.
    let simulation = null; // intentionally null: no ongoing force layout

    // run initial layout now
    computeInitialLayout(300);

// ...existing code...

    // VIEW transform

    function computeFit(marginRatio = 0.08) {
        // pick nodes that are visible (or all)
        const visibleNodes = nodes.filter(n => n.visible !== false);
        const used = visibleNodes.length ? visibleNodes : nodes;
        if (!used.length) {
            view = { scale: 1, tx: 0, ty: 0 };
            return;
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        used.forEach(n => {
            if (n.x < minX) minX = n.x;
            if (n.y < minY) minY = n.y;
            if (n.x > maxX) maxX = n.x;
            if (n.y > maxY) maxY = n.y;
        });
        const bw = Math.max(1, maxX - minX);
        const bh = Math.max(1, maxY - minY);
        const marginW = width * marginRatio;
        const marginH = height * marginRatio;
        const availableW = Math.max(1, width - marginW * 2);
        const availableH = Math.max(1, height - marginH * 2);
        let scaleX = availableW / bw;
        let scaleY = availableH / bh;
        // prefer X compression (we want Y to be compact), so choose a scale that favors width fit
        let scale = Math.min(scaleX, scaleY);
        scale = Math.min(scale, 1.5);
        scale = Math.max(0.02, scale);
        const bboxCx = (minX + maxX) / 2;
        const bboxCy = (minY + maxY) / 2;
        const tx = width / 2 - bboxCx * scale;
        const ty = height / 2 - bboxCy * scale;
        view = { scale, tx, ty };
    }

    // initial fit
    computeFit();

    // helper: quadratic control same as before
    function computeQuadraticControl(sourceX, sourceY, targetX, targetY, total, offset) {
        // 减小弧度幅度，并使多条并列弧线在两侧交替分布（而不是都偏向同一侧）
        const center = (total - 1) / 2;
        const idx = offset ? (offset / 3 + center) : 0;
        const delta = idx - center;
        // 曲率基准值（调小以减小弧度）
        const BASE_CURVE = 20;
        // 根据与中心的距离放大曲率，但使用交替符号实现两侧分布
        const magnitude = Math.abs(delta) + 0.5; // +0.5 保证最小偏移
        const sign = (Math.round(Math.abs(delta)) % 2 === 0) ? 1 : -1;
        const curve = BASE_CURVE * magnitude * sign;

        const dx = targetX - sourceX;
        const dy = targetY - sourceY;
        const len = Math.hypot(dx, dy) || 1;
        const cx = (sourceX + targetX) / 2 + curve * (dy) / len;
        const cy = (sourceY + targetY) / 2 - curve * (dx) / len;
        return { cx, cy };
    }

    // distance from point to quadratic bezier
    function distancePointToQuadratic(px, py, x0, y0, cx, cy, x1, y1, steps = 28) {
        let minDist = Infinity;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const ix = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * cx + t * t * x1;
            const iy = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * cy + t * t * y1;
            const d = Math.hypot(px - ix, py - iy);
            if (d < minDist) minDist = d;
        }
        return minDist;
    }

    // update node send/recv counters for a given date (we store counts on node objects)
    function updateNodeCounters(date) {
        // zero counters first
        nodes.forEach(n => { n.sentCount = 0; n.recvCount = 0; });
        // iterate lettersData and increment counters for those <= date
        lettersData.forEach(ld => {
            const dObj = ld.dateObj ? ld.dateObj : new Date(ld.date);
            if (dObj <= date) {
                // sender increments sentCount (if node exists)
                const sNode = nodeById[ld.sender];
                if (sNode) sNode.sentCount = (sNode.sentCount || 0) + 1;
                // receivers: could be array
                (ld.receivers || []).forEach(rcv => {
                    const rNode = nodeById[rcv];
                    if (rNode) rNode.recvCount = (rNode.recvCount || 0) + 1;
                });
            }
        });
    }

    // core: onTick renders scene (no force layout updates here)
    function onTick() {
        if (!(currentDate instanceof Date)) currentDate = new Date(minDate);

        // update visibility based on currentDate (播放控制可见性，不影响位置)
        nodes.forEach(n => { n.visible = n.registerDateObj <= currentDate; });
        links.forEach(l => {
            l.visible = (l.source.registerDateObj <= currentDate) &&
                        (l.target.registerDateObj <= currentDate) &&
                        (l.dateObj <= currentDate);
        });

        // 时间差用于惯性积分（ms -> s）
        const now = Date.now();
        if (typeof onTick._lastNow === 'undefined') onTick._lastNow = now;
        const dt = Math.min(40, now - onTick._lastNow) / 1000; // cap dt to avoid big jumps
        onTick._lastNow = now;

        // 更新惯性：若节点被标记为有惯性，则按速度移动，并施加阻尼；速度耗尽后固定位置（fx/fy）
        const FRICTION = 0.85;      // 每帧阻尼（0..1），可调，越小越快停
        const VELOCITY_EPS = 4e-3;  // 速度阈值（px/s）以下视为静止
        nodes.forEach(n => {
            if (n._inertiaActive) {
                // 移动位置（以秒为单位）
                n.x += n.vx * dt;
                n.y += n.vy * dt;
                // 衰减速度
                n.vx *= Math.pow(FRICTION, dt * 60);
                n.vy *= Math.pow(FRICTION, dt * 60);
                // 停止条件
                if (Math.hypot(n.vx, n.vy) < VELOCITY_EPS) {
                    n.vx = 0; n.vy = 0; n._inertiaActive = false;
                    // 固定最终位置
                    n.fx = n.x;
                    n.fy = n.y;
                } else {
                    // 未停止时确保不被其它逻辑覆盖 fx/fy（保持自由移动）
                    n.fx = null;
                    n.fy = null;
                }
            }
        });

        // clear and set transform
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(DPR * view.scale, 0, 0, DPR * view.scale, DPR * view.tx, DPR * view.ty);

        // stars (unchanged) ...
        // draw links (base) — 使用 display position（随 jitter 一起动）
        ctx.save();
        ctx.lineCap = 'round';
        links.forEach(l => {
            if (!l.visible) return;
            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
            let stroke = 'rgba(150,150,150,0.7)';
            if (l.isOCSender) {
                if (l.type === 'B') stroke = 'rgba(255,100,100,0.7)';
                if (l.type === 'C') stroke = 'rgba(100,200,255,0.85)'; // OC 发出的 C 线为较亮的蓝
            } else {
                if (l.type === 'A') stroke = 'rgba(0,255,255,0.7)';
                if (l.type === 'B') stroke = 'rgba(255,100,255,0.7)';
                if (l.type === 'C') stroke = 'rgba(80,170,255,0.75)'; // 非 OC 的 C 线为蓝色系
            }
            ctx.beginPath();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = l.isOCSender ? (l.type === 'C' ? 2.5 : 2) : (l.type === 'C' ? 2 : 1);
            ctx.globalAlpha = 0.25;
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(ctrl.cx, ctrl.cy, tx, ty);
            ctx.stroke();
            // start
            // 新增：在曲线靠近终点处绘制方向箭头
            (function drawArrowOnQuad(tPos = 0.95) {
                // 位置 tPos (0..1) 控制箭头在曲线上靠近终点的位置
                const t = Math.max(0.01, Math.min(0.99, tPos));
                const ix = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * ctrl.cx + t * t * tx;
                const iy = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * ctrl.cy + t * t * ty;
                // derivative B'(t) = 2(1-t)(C - P0) + 2t(P1 - C)
                const dx = 2 * (1 - t) * (ctrl.cx - sx) + 2 * t * (tx - ctrl.cx);
                const dy = 2 * (1 - t) * (ctrl.cy - sy) + 2 * t * (ty - ctrl.cy);
                const dist = Math.hypot(tx - sx, ty - sy);
                if (dist < 8) return; // 太短则不绘制箭头
                const angle = Math.atan2(dy, dx);

                // 箭头在“世界坐标”中应控制大小以在不同缩放下视觉一致
                const screenArrowPx = 8; // 目标屏幕像素大小
                const arrowLen = Math.max(4, screenArrowPx / Math.max(0.2, view.scale));
                const arrowW = Math.max(3, arrowLen * 0.6);

                ctx.save();
                ctx.translate(ix, iy);
                ctx.rotate(angle);
                ctx.globalAlpha = 0.95;
                // 箭头颜色尽量与线色一致但更实心
                try {
                    ctx.fillStyle = stroke || 'rgba(255,255,255,0.95)';
                } catch (e) {
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                }
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-arrowLen, arrowW / 2);
                ctx.lineTo(-arrowLen, -arrowW / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            })();

            // end
        });
        ctx.restore();

        // broadcast lines for OC B — 使用 display pos
// ...existing code...
// broadcast lines for OC B — 固定角度，长度伸缩，末端透明渐隐（替换原实现）
ctx.save();
ctx.lineWidth = 1.5;
const nowSec = Date.now() / 1000;
lettersData.forEach(letter => {
    if (letter.type === "B" && letter.isOCSender && letter.isBroadcast) {
        const senderNode = nodeById[letter.sender];
        if (!senderNode || !senderNode.visible) return;
        const letterDate = letter.dateObj ? letter.dateObj : new Date(letter.date);
        if (letterDate > currentDate) return;
        const sp = getDisplayPos(senderNode);

        const lineCount = 5;
        // 初始化每条线的固定角度 / 相位 / 基础长度 / 振幅 / 速度
        if (!letter._bcastState) {
            letter._bcastState = { angles: [], phases: [], baseLen: [], amps: [], speeds: [] };
            for (let ii = 0; ii < lineCount; ii++) {
                // 固定角度均匀分布并加一点微随机扰动（角度不随时间变化）
                letter._bcastState.angles[ii] = (2 * Math.PI * ii / lineCount) + (Math.random() - 0.5) * 0.06;
                letter._bcastState.phases[ii] = Math.random() * Math.PI * 2;
                letter._bcastState.baseLen[ii] = 28 + ii * 8 + Math.random() * 6; // 基础长度
                letter._bcastState.amps[ii] = 6 + Math.random() * 16;               // 伸缩振幅
                letter._bcastState.speeds[ii] = 0.6 + Math.random() * 1.2;          // 速度（rad/s）
            }
        }
        const st = letter._bcastState;

        for (let i = 0; i < lineCount; i++) {
            const ang = st.angles[i];
            const phase = st.phases[i];
            const base = st.baseLen[i];
            const amp = st.amps[i];
            const speed = st.speeds[i];

            // 长度在 base .. base+amp 之间平滑变化（非旋转）
            const len = base + amp * (0.5 + 0.5 * Math.sin(phase + nowSec * speed));

            const ex = sp.x + Math.cos(ang) * len;
            const ey = sp.y + Math.sin(ang) * len;

            // 线性渐变：中心较不透明，末端透明
            const grad = ctx.createLinearGradient(sp.x, sp.y, ex, ey);
            // 颜色可调整，这里用偏红到透明（OC B 风格）
            grad.addColorStop(0.0, 'rgba(255,140,120,0.65)');
            grad.addColorStop(0.6, 'rgba(255,140,120,0.65)');
            grad.addColorStop(1.0, 'rgba(255,140,120,0.65)');

            ctx.strokeStyle = grad;
            ctx.lineWidth = 1.4;
            ctx.beginPath();
            ctx.moveTo(sp.x, sp.y);
            ctx.lineTo(ex, ey);
            ctx.stroke();

            // 可选末端小光斑（半透明）增加视觉
            ctx.fillStyle = 'rgba(255,200,180,0.65)';
            ctx.beginPath();
            ctx.arc(ex, ey, 2.2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
});
ctx.restore();
// ...existing code...

        // A-rings — 使用 display pos
        ctx.save();
        Object.keys(senderRings).forEach(sender => {
            const owner = nodeById[sender];
            if (!owner || !owner.visible) return;
            const sp = getDisplayPos(owner);
            const arr = senderRings[sender];
            arr.forEach((rObj, idx) => {
                if (rObj.dateObj > currentDate) return;
                const rad = 12 + idx * 8;
                const alpha = Math.max(0.2, 0.7 - idx * 0.08);
                ctx.beginPath();
                ctx.strokeStyle = `rgba(0,255,255,${alpha})`;
                ctx.lineWidth = 1;
                ctx.globalCompositeOperation = 'lighter';
                ctx.arc(sp.x, sp.y, rad, 0, Math.PI * 2);
                ctx.stroke();
            });
        });
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();

        // pulse rings — 使用 display pos
        ctx.save();
        pulseRings.forEach(p => {
            const ownerNode = nodeById[p.ownerId];
            if (!ownerNode || !ownerNode.visible) return;
            const sp = getDisplayPos(ownerNode);
            if (p.growing) {
                p.currentRadius += p.speed;
                if (p.currentRadius >= p.maxRadius) { p.currentRadius = p.maxRadius; p.growing = false; }
            } else {
                p.currentRadius -= p.speed;
                if (p.currentRadius <= p.minRadius) { p.currentRadius = p.minRadius; p.growing = true; }
            }
            const fade = 0.15 - (p.currentRadius - p.minRadius) / (p.maxRadius - p.minRadius) * 0.1;
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = `hsla(${p.colorH},100%,70%,${Math.max(0.05, fade)})`;
            ctx.arc(sp.x, sp.y, p.currentRadius, 0, Math.PI * 2);
            ctx.stroke();
        });
        ctx.restore();

        // particles — 使用 display pos
ctx.save();
particles.forEach(pr => {
    // 防御：若 links 结构变化，确保重绑定
    let l = links[pr.linkIndex];
    if (!l) {
        // 试图重新分配到一条存在的链接
        const elig = [];
        for (let ii = 0; ii < links.length; ii++) if (links[ii].type === 'B' || links[ii].type === 'C') elig.push(ii);
        if (elig.length === 0) return;
        pr.linkIndex = elig[Math.floor(Math.random() * elig.length)];
        l = links[pr.linkIndex];
    }
    // 如果目标不可见或链接当前不活跃，允许仍然推进位置，
    // 到达终点时会随机切换到另一条线，避免永久集中在密集线
    pr.position += pr.speed;
    if (pr.position > 1) {
        pr.position = Math.random() * 0.12; // 到达后短暂重新出现，避免“同一时刻都在起点”
        // 随机切换到另一条可用链接
        const elig = [];
        for (let ii = 0; ii < links.length; ii++) if (links[ii].type === 'B' || links[ii].type === 'C') elig.push(ii);
        if (elig.length > 0) pr.linkIndex = elig[Math.floor(Math.random() * elig.length)];
        l = links[pr.linkIndex];
    }
    if (!l || !l.visible) return; // 仅在可见时绘制

    const sPos = getDisplayPos(l.source);
    const tPos = getDisplayPos(l.target);
    const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
    const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
    const t = Math.max(0, Math.min(1, pr.position));
    const x = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * ctrl.cx + t * t * tx;
    const y = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * ctrl.cy + t * t * ty;

    // 渐变 / 光点效果
    ctx.beginPath();
    ctx.fillStyle = pr.color;
    ctx.globalAlpha = 0.95;
    ctx.arc(x, y, pr.size, 0, Math.PI * 2);
    ctx.fill();
});
ctx.restore();

        // jitter update (for visual wobble) — 保持不变
        nodes.forEach(n => {
            const j = nodeJitter[n.id];
            if (!j) { n._dx = 0; n._dy = 0; return; }
            const t = now * j.speed + j.phase;
            n._dx = Math.sin(t) * j.ampX;
            n._dy = Math.cos(t) * j.ampY;
        });

        // nodes 绘制（使用 display pos） ...
        ctx.save();
        nodes.forEach((n, i) => {
            if (!n.visible) return;
            const d = getDisplayPos(n);
            const drawX = d.x;
            const drawY = d.y;

            ctx.beginPath();
            ctx.fillStyle = n.isOC ? `hsla(${120 + (i * 12) % 360},100%,60%,0.75)` : `hsla(${180 + (i * 8) % 360},100%,55%,0.6)`;
            ctx.shadowColor = 'rgba(0,255,255,0.18)';
            ctx.shadowBlur = n.isOC ? 6 : 3;
            ctx.arc(drawX, drawY, n.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            if (n.isOC) {
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.font = `${Math.max(8, Math.floor(n.r * 0.7))}px zpix, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('OC', drawX, drawY);
                ctx.restore();
            }
        });
        ctx.restore();

        // overlay highlights — 使用 display pos
        if (hoveredLink) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgba(255,255,255,0.95)';
            ctx.globalAlpha = 1;
            const l = hoveredLink;
            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(ctrl.cx, ctrl.cy, tx, ty);
            ctx.stroke();
            ctx.restore();
        }
        if (hoveredNode) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,255,0.95)';
            const pos = getDisplayPos(hoveredNode);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, hoveredNode.r + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        if (hoveredRing) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,255,0.95)';
            const ownerPos = getDisplayPos(hoveredRing.owner);
            ctx.beginPath();
            ctx.arc(ownerPos.x, ownerPos.y, hoveredRing.rad, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    } // end onTick
    // continuous render loop (we are not relying on d3 simulation ticks anymore)
    function continuousRender() {
        onTick();
        requestAnimationFrame(continuousRender);
    }
    continuousRender();

    // interaction / state for dragging/panning
    let draggingNode = null;
    let dragOffset = { x: 0, y: 0 };
    let panning = false;
    let panStart = null;

    // client -> world conversion using view transform
    function clientToWorld(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const cssX = clientX - rect.left;
        const cssY = clientY - rect.top;
        const worldX = (cssX - view.tx) / view.scale;
        const worldY = (cssY - view.ty) / view.scale;
        return { worldX, worldY, cssX, cssY };
    }

    function findNodeAtWorld(x, y) {
        for (let i = nodes.length - 1; i >= 0; i--) {
            const n = nodes[i];
            if (!n.visible) continue;
            const dx = x - n.x;
            const dy = y - n.y;
            if (Math.hypot(dx, dy) <= n.r + 4) return n;
        }
        return null;
    }

    function findLinkAtWorld(x, y, threshold = 8 / Math.max(0.001, view.scale)) {
        for (let i = 0; i < links.length; i++) {
            const l = links[i];
            if (!l.visible) continue;
            // 使用 display pos（包含 jitter / 惯性偏移），与视觉一致
            const sPos = getDisplayPos(l.source);
            const tPos = getDisplayPos(l.target);
            const sx = sPos.x, sy = sPos.y, tx = tPos.x, ty = tPos.y;
            const ctrl = computeQuadraticControl(sx, sy, tx, ty, l.totalConnections || 1, l.offset);
            const dist = distancePointToQuadratic(x, y, sx, sy, ctrl.cx, ctrl.cy, tx, ty, 30);
            if (dist <= threshold) return l;
        }
        return null;
    }

    function findRingAtWorld(x, y, threshold = 6 / Math.max(0.001, view.scale)) {
        for (const sender of Object.keys(senderRings)) {
            const owner = nodeById[sender];
            if (!owner || !owner.visible) continue;
            const arr = senderRings[sender];
            for (let idx = 0; idx < arr.length; idx++) {
                const rObj = arr[idx];
                if (rObj.dateObj > currentDate) continue;
                const rad = 12 + idx * 8;
                // 使用 display pos 与视觉一致
                const sp = getDisplayPos(owner);
                const d = Math.hypot(x - sp.x, y - sp.y);
                if (Math.abs(d - rad) <= threshold) {
                    return { owner, idx, rad, rObj };
                }
            }
        }
        return null;
    }

    function showTooltipAtClient(clientX, clientY, html) {
        if (!tooltip) return;
        tooltip.innerHTML = html;
        tooltip.style.left = (clientX + 12) + 'px';
        tooltip.style.top = (clientY - 20) + 'px';
        tooltip.style.opacity = '1';
        tooltip.style.display = 'block';
    }
    function hideTooltip() {
        if (!tooltip) return;
        tooltip.style.opacity = '0';
        tooltip.style.display = 'none';
    }

    // Mousemove handler: hover, dragging, panning
// ...existing code...

// ===== 完整替换：mousemove / mousedown / mouseup（带拖拽速度采样与惯性） =====

    // utility: push a sample into node._dragSamples (bounded)
    function _pushDragSample(node, x, y, t) {
        if (!node._dragSamples) node._dragSamples = [];
        node._dragSamples.push({ x, y, t });
        if (node._dragSamples.length > 6) node._dragSamples.shift(); // keep recent samples
    }

    // mousemove: hover, drag (record samples), pan
    canvas.addEventListener('mousemove', (evt) => {
        // dragging node: update fx/fy and record drag sample for velocity calc
        if (draggingNode) {
            const p = clientToWorld(evt.clientX, evt.clientY);
            const newFx = p.worldX - dragOffset.x;
            const newFy = p.worldY - dragOffset.y;
            draggingNode.fx = newFx;
            draggingNode.fy = newFy;
            // update node coords for instant visual response
            draggingNode.x = newFx;
            draggingNode.y = newFy;
            // record sample (use ms timestamp)
            _pushDragSample(draggingNode, newFx, newFy, Date.now());
            // update tooltip position if visible
            if (tooltip && tooltip.style.display === 'block') {
                tooltip.style.left = (evt.clientX + 12) + 'px';
                tooltip.style.top = (evt.clientY - 20) + 'px';
            }
            return;
        }

        // panning
        if (panning && panStart) {
            const dx = evt.clientX - panStart.clientX;
            const dy = evt.clientY - panStart.clientY;
            view.tx = panStart.viewTx + dx;
            view.ty = panStart.viewTy + dy;
            if (tooltip && tooltip.style.display === 'block') {
                tooltip.style.left = (evt.clientX + 12) + 'px';
                tooltip.style.top = (evt.clientY - 20) + 'px';
            }
            return;
        }

        // hover detection (use world coords; findNodeAtWorld uses n.x/n.y)
        const p = clientToWorld(evt.clientX, evt.clientY);
        const worldX = p.worldX, worldY = p.worldY;
        const node = findNodeAtWorld(worldX, worldY);

        if (node !== hoveredNode) {
            if (expandedItem) expandedItem = null;
            hoveredNode = node;
            hoveredLink = null;
            hoveredRing = null;
            if (!node) {
                hideTooltip();
            } else {
                const sent = node.sentCount || 0;
                const recv = node.recvCount || 0;
                const html = `<b>发信人：</b>${node.id}<br><b>发出：</b>${sent}<br><b>收到：</b>${recv}`;
                showTooltipAtClient(evt.clientX, evt.clientY, html);
            }
        } else {
            // same node - update tooltip position only
            if (hoveredNode && tooltip && tooltip.style.display === 'block') {
                tooltip.style.left = (evt.clientX + 12) + 'px';
                tooltip.style.top = (evt.clientY - 20) + 'px';
            }
        }

        if (!hoveredNode) {
            const link = findLinkAtWorld(worldX, worldY);
            if (link && link !== hoveredLink) {
                if (expandedItem) expandedItem = null;
                hoveredLink = link;
                hoveredRing = null;
                const letter = link.rawLetter || {};
                const sender = link.source.id;
                const receivers = link.target.id;
                const number = link.number || (letter.number || '');
                const date = link.date || (letter.date || '');
                const type = link.type || (letter.type || '');
                const html = `<b>发件：</b>${sender}<br><b>收件：</b>${receivers}<br><b>编号：</b>${number}<br><b>日期：</b>${date}<br><b>类型：</b>${type}`;
                showTooltipAtClient(evt.clientX, evt.clientY, html);
            } else if (!link) {
                if (hoveredLink) {
                    hoveredLink = null;
                    hideTooltip();
                }
            } else {
                if (hoveredLink && tooltip && tooltip.style.display === 'block') {
                    tooltip.style.left = (evt.clientX + 12) + 'px';
                    tooltip.style.top = (evt.clientY - 20) + 'px';
                }
            }

            // rings
            if (!hoveredLink && !hoveredNode) {
                const ringHit = findRingAtWorld(worldX, worldY);
                if (ringHit) {
                    if (expandedItem) expandedItem = null;
                    hoveredLink = null;
                    hoveredNode = null;
                    hoveredRing = ringHit;
                    const rObj = ringHit.rObj;
                    const sender = ringHit.owner.id;
                    const receivers = (rObj.letter && rObj.letter.receivers) ? rObj.letter.receivers.join(',') : '';
                    const number = (rObj.letter && rObj.letter.number) || '';
                    const date = (rObj.letter && rObj.letter.date) || rObj.dateObj.toISOString().slice(0,10);
                    const type = 'A';
                    const html = `<b>发件：</b>${sender}<br><b>收件：</b>${receivers}<br><b>编号：</b>${number}<br><b>日期：</b>${date}<br><b>类型：</b>${type}`;
                    showTooltipAtClient(evt.clientX, evt.clientY, html);
                } else {
                    hoveredRing = null;
                }
            } else {
                hoveredRing = null;
            }
        } else {
            hoveredLink = null;
            hoveredRing = null;
        }
    });

    // mousedown: either start dragging node or panning (初始化拖拽采样)
    canvas.addEventListener('mousedown', (evt) => {
        if (evt.button !== 0) return;
        const p = clientToWorld(evt.clientX, evt.clientY);
        const node = findNodeAtWorld(p.worldX, p.worldY);
        if (node) {
            draggingNode = node;
            dragOffset.x = p.worldX - node.x;
            dragOffset.y = p.worldY - node.y;
            // lock node to mouse by setting fx/fy (keep visual follow)
            node.fx = node.x;
            node.fy = node.y;
            // prepare drag samples (fresh)
            node._dragSamples = [{ x: node.x, y: node.y, t: Date.now() }];
            canvas.style.cursor = 'grabbing';
        } else {
            panning = true;
            panStart = {
                clientX: evt.clientX,
                clientY: evt.clientY,
                viewTx: view.tx,
                viewTy: view.ty
            };
            canvas.style.cursor = 'grabbing';
        }
    });

    // mouseup: stop dragging or panning -> 计算释放速度并启用惯性
    window.addEventListener('mouseup', (evt) => {
        if (draggingNode) {
            // compute velocity from last samples
            const samples = draggingNode._dragSamples || [];
            let vx = 0, vy = 0;
            if (samples.length >= 2) {
                // use last two samples for dt-average
                const a = samples[samples.length - 2];
                const b = samples[samples.length - 1];
                const dt = Math.max(1, b.t - a.t) / 1000; // seconds
                if (dt > 0) {
                    vx = (b.x - a.x) / dt;
                    vy = (b.y - a.y) / dt;
                }
            }
            // clamp excessive velocity
            const MAX_V = 5000; // px/s
            vx = Math.max(-MAX_V, Math.min(MAX_V, vx));
            vy = Math.max(-MAX_V, Math.min(MAX_V, vy));

            // set velocity and enable inertia integration in onTick
            draggingNode.vx = vx;
            draggingNode.vy = vy;
            draggingNode._inertiaActive = (Math.hypot(vx, vy) > 1e-2);

            // release fixed position so onTick can move node if inertia active
            if (draggingNode._inertiaActive) {
                draggingNode.fx = null;
                draggingNode.fy = null;
            } else {
                // keep fixed at current spot
                draggingNode.fx = draggingNode.x;
                draggingNode.fy = draggingNode.y;
            }

            // cleanup samples
            delete draggingNode._dragSamples;
            draggingNode = null;
            canvas.style.cursor = 'default';
        }
        if (panning) {
            panning = false;
            panStart = null;
            canvas.style.cursor = 'default';
        }
    });


// 状态：记录被“展开查看全文”的项（{type:'link'|'ring', id: unique}），鼠标移开后会清除
let expandedItem = null;

function resolveLetterCandidates(rawPath) {
    if (!rawPath) return [];
    let p = rawPath.replace(/\\/g, '/').trim();

    // Windows 绝对路径（如 D:/ZJU/... 或 D:\ZJU\...）
    if (/^[A-Za-z]:\//.test(p)) {
        // 去掉尾部斜杠
        const folder = p.replace(/\/+$/, '');
        // 直接尝试 file:/// 协议下的常见文件名（content.txt 优先）
        return [
            `file:///${folder}/content.txt`,
            `file:///${folder}/xontnt.txt`,
            `file:///${folder}/内容.txt`,
            `file:///${folder}/content_utf8.txt`
        ];
    }

    // 项目内相对路径或以 /email/ 的路径 -> 转为相对 ./email/...
    const idx = p.indexOf('/email/');
    if (idx !== -1) {
        p = '.' + p.slice(idx);
    } else {
        const m = p.match(/.*(email\/.*)$/i);
        if (m && m[1]) p = './' + m[1];
    }
    p = p.replace(/\/+$/, '');

    const candidates = [];
    if (p.match(/\.[a-z0-9]+$/i)) {
        candidates.push(p);
    } else {
        candidates.push(`${p}/content.txt`);
        candidates.push(`${p}/xontnt.txt`);
        candidates.push(`${p}/内容.txt`);
        candidates.push(`${p}.txt`);
        candidates.push(`${p}/content_utf8.txt`);
    }
    return [...new Set(candidates)];
}

// helper: 异步读取并显示信件全文到浮框。按候选路径依次尝试（支持 file:///...）
function showLetterFullContentAtClient(clientX, clientY, rawPath, fallbackHtml) {
    const candidates = resolveLetterCandidates(rawPath);
    if (!candidates.length) {
        showTooltipAtClient(clientX, clientY, `<pre style="white-space:pre-wrap">${escapeHtml(fallbackHtml || 'No path')}</pre>`);
        return Promise.resolve();
    }

    const tryFetch = (i) => {
        if (i >= candidates.length) {
            const msg = `无法读取信件全文（尝试路径：${candidates.join(', ')})`;
            showTooltipAtClient(clientX, clientY, `<div>${escapeHtml(msg)}</div><pre style="white-space:pre-wrap">${escapeHtml(fallbackHtml || '')}</pre>`);
            return Promise.resolve();
        }
        const url = candidates[i];
        return fetch(url).then(resp => {
            if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
            return resp.text();
        }).then(text => {
            const html = `<pre style="white-space:pre-wrap; max-width:520px; color:#dff">${escapeHtml(text)}</pre>`;
            showTooltipAtClient(clientX, clientY, html);
        }).catch(() => {
            return tryFetch(i + 1);
        });
    };

    return tryFetch(0);
}
// 简单 HTML 转义
function escapeHtml(s) {
    if (s == null) return '';
    return String(s).replace(/[&<>"']/g, ch => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[ch]));
}

// ...existing code...

// ---------- 新增：可移动/可关闭的信件详情弹窗（支持多开） ----------
(function(){
    // inject minimal styles
    const s = document.createElement('style');
    s.textContent = `
    .email-popup {
        position: fixed;
        width: 420px;
        max-width: 80vw;
        max-height: 70vh;
        background: rgba(10,10,14,0.95);
        color: #e6f9ff;
        border: 1px solid rgba(0,200,255,0.14);
        box-shadow: 0 6px 30px rgba(0,0,0,0.6);
        border-radius: 6px;
        overflow: hidden;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        font-family: inherit;
    }
    .email-popup .hdr {
        cursor: move;
        background: linear-gradient(90deg, rgba(0,120,180,0.12), rgba(0,200,255,0.06));
        padding: 8px 10px;
        display:flex;
        justify-content:space-between;
        align-items:center;
        user-select: none;
    }
    .email-popup .hdr .title { font-weight:600; color:#bff; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .email-popup .hdr .actions { display:flex; gap:6px; }
    .email-popup .hdr button { background:transparent; border:0; color:#9ff; cursor:pointer; padding:4px; font-size:14px; }
    .email-popup .body { padding:10px; overflow:auto; flex:1; font-size:13px; line-height:1.4; white-space:pre-wrap; color:#dff; }
    .email-popup .foot { padding:6px 8px; text-align:right; font-size:12px; color:#99d; background:rgba(0,0,0,0.04); }
    `;
    document.head.appendChild(s);

    // bring a popup to front
    let _popupZ = 2100;
    function bringToFront(el) {
        el.style.zIndex = ++_popupZ;
    }

    // create popup element
    window.__createEmailPopup = function(title, left, top) {
        const popup = document.createElement('div');
        popup.className = 'email-popup';
        popup.style.left = (left || (window.innerWidth/2 - 210)) + 'px';
        popup.style.top = (top || (window.innerHeight/2 - 140)) + 'px';
        popup.style.width = '420px';
        popup.innerHTML = `
            <div class="hdr">
                <div class="title">${escapeHtml(title || '信件详情')}</div>
                <div class="actions">
                    <button class="btn-close" title="关闭">✕</button>
                </div>
            </div>
            <div class="body">加载中...</div>
            <div class="foot"><small>可拖拽，右上关闭</small></div>
        `;
        document.body.appendChild(popup);
        bringToFront(popup);

        const hdr = popup.querySelector('.hdr');
        const body = popup.querySelector('.body');
        const closeBtn = popup.querySelector('.btn-close');

        // draggable
        let dragging = false, dx = 0, dy = 0;
        hdr.addEventListener('mousedown', (e) => {
            dragging = true;
            bringToFront(popup);
            const rect = popup.getBoundingClientRect();
            dx = e.clientX - rect.left;
            dy = e.clientY - rect.top;
            document.addEventListener('mousemove', _onmove);
            document.addEventListener('mouseup', _onup);
            e.preventDefault();
        });
        function _onmove(ev) {
            if (!dragging) return;
            // 不强制限制到可见区域，允许弹窗部分在窗口外
            popup.style.left = (ev.clientX - dx) + 'px';
            popup.style.top = (ev.clientY - dy) + 'px';
        }
        function _onup() {
            dragging = false;
            document.removeEventListener('mousemove', _onmove);
            document.removeEventListener('mouseup', _onup);
        }

        // focus on mousedown
        popup.addEventListener('mousedown', () => bringToFront(popup));

        // close
        closeBtn.addEventListener('click', () => {
            popup.remove();
        });

        return { popup, body, setTitle: t => popup.querySelector('.title').textContent = t, close: () => popup.remove() };
    };
})();


// 替换原有的 canvas.addEventListener('click', ...) 整段为下面实现
canvas.addEventListener('click', (evt) => {
    // 优先使用 mousemove 已设置的 hoveredLink / hoveredRing
    if (hoveredLink) {
        const rawLetter = hoveredLink.rawLetter || {};
        const rawPath = rawLetter.path || hoveredLink.path || '';
        const title = `${hoveredLink.source.id} → ${hoveredLink.target.id} ${hoveredLink.number || ''}`.trim();
        // open movable popup at click position
        const { popup, body, setTitle } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
        // try candidates and fill body
        const candidates = resolveLetterCandidates(rawPath || '');
        if (!candidates.length) {
            body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
            return;
        }
        body.textContent = '正在读取信件...';
        // try sequentially
        (function tryOne(i){
            if (i >= candidates.length) {
                body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                return;
            }
            fetch(candidates[i]).then(r => {
                if (!r.ok) throw new Error('HTTP ' + r.status);
                return r.text();
            }).then(txt => {
                body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
            }).catch(() => tryOne(i+1));
        })(0);
        return;
    }

    if (hoveredRing) {
        const rObj = hoveredRing.rObj || {};
        const rawLetter = rObj.letter || rObj || {};
        const rawPath = rawLetter.path || '';
        const title = `信件：${hoveredRing.owner.id} ${ (rObj.dateObj ? rObj.dateObj.toISOString().slice(0,10) : (rObj.date||'')) }`;
        const { popup, body } = window.__createEmailPopup(title, evt.clientX + 8, evt.clientY + 8);
        const candidates = resolveLetterCandidates(rawPath || '');
        if (!candidates.length) {
            body.innerHTML = `<div>无可用路径</div><pre>${escapeHtml(JSON.stringify(rawLetter) || '')}</pre>`;
            return;
        }
        body.textContent = '正在读取信件...';
        (function tryOne(i){
            if (i >= candidates.length) {
                body.innerHTML = `<div>无法读取信件（尝试路径：${escapeHtml(candidates.join(', '))}）</div>`;
                return;
            }
            fetch(candidates[i]).then(r => {
                if (!r.ok) throw new Error('HTTP ' + r.status);
                return r.text();
            }).then(txt => {
                body.innerHTML = `<pre style="white-space:pre-wrap; color:#dff; margin:0">${escapeHtml(txt)}</pre>`;
            }).catch(() => tryOne(i+1));
        })(0);
        return;
    }

    // 点击空白不再自动关闭弹窗或 tooltip（弹窗由用户关闭）
});

// 在 mousemove 里：当 hover 项改变时，若存在 expandedItem 则清除（保证离开后再次回到显示简要）
// 下面为补丁：在 canvas.addEventListener('mousemove', ...) 内合适位置（当 hoveredNode/hoveredLink/hoveredRing 发生变化时）
// 将下面短逻辑插入到你的 mousemove 变化处理处（即当设置 hoveredNode = node; hoveredLink = link; hoveredRing = ring 的地方）：
/*
    // 当 hover 变化时清除已展开的全文状态（以保证再次进入时显示简要）
    if (expandedItem) {
        expandedItem = null;
        // 不要立即 hideTooltip 如果你想显示新的简要框可以依赖后续 hover 分支显示
    }
*/

// ...existing code...

    canvas.addEventListener('dblclick', (evt) => {
        // reset fit
        computeFit();
    });

    // wheel zoom (center on mouse)
    canvas.addEventListener('wheel', (evt) => {
        evt.preventDefault();
        const delta = -evt.deltaY;
        const zoomFactor = Math.exp(delta * 0.0012);
        const rect = canvas.getBoundingClientRect();
        const cssX = evt.clientX - rect.left;
        const cssY = evt.clientY - rect.top;
        const wx = (cssX - view.tx) / view.scale;
        const wy = (cssY - view.ty) / view.scale;
        let newScale = view.scale * zoomFactor;
        newScale = Math.max(0.02, Math.min(4, newScale));
        view.tx = cssX - wx * newScale;
        view.ty = cssY - wy * newScale;
        view.scale = newScale;
        if (tooltip && tooltip.style.display === 'block') {
            tooltip.style.left = (evt.clientX + 12) + 'px';
            tooltip.style.top = (evt.clientY - 20) + 'px';
        }
    }, { passive: false });

    // time controls (reuse DOM if present)
    const timeSlider = document.getElementById('timeSlider');
    const timeDisplay = document.getElementById('timeDisplay');
    const playButton = document.getElementById('playButton');
    const resetButton = document.getElementById('resetButton');
    const speedOptions = document.querySelectorAll('.speed-option');

    if (timeSlider) {
        timeSlider.min = 0;
        timeSlider.max = 100;
        timeSlider.value = 0;
    }

    function updateTimeDisplay(date) {
        const d = date || currentDate;
        if (timeDisplay) timeDisplay.textContent = d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }

    function setCurrentDateFromSliderValue(valuePercent) {
        const p = Math.max(0, Math.min(100, Number(valuePercent)));
        const timeRange = maxDate.getTime() - minDate.getTime();
        const newTime = minDate.getTime() + (timeRange * (p / 100));
        currentDate = new Date(newTime);
        filterByDate(currentDate);
        onTick();
    }

// ...existing code...

    function filterByDate(date) {
        // set visibility (onTick will draw accordingly)
        nodes.forEach(n => n.visible = n.registerDateObj <= date);
        links.forEach(link => {
            const sourceVisible = link.source && link.source.registerDateObj && link.source.registerDateObj <= date;
            const targetVisible = link.target && link.target.registerDateObj && link.target.registerDateObj <= date;
            link.visible = sourceVisible && targetVisible && link.dateObj <= date;
        });
        // update counters for tooltips
        updateNodeCounters(date);
        updateTimeDisplay(date);
        // 不要在播放过程中重新计算布局或视图：时间线只控制可见性
        // 如需用户触发的“聚焦可见子集”，请提供单独按钮调用 computeFit()
    }

// ...existing code...
    if (timeSlider) {
        timeSlider.addEventListener('input', function() {
            setCurrentDateFromSliderValue(this.value);
        });
    }

    function startPlay() {
        if (playInterval) return;
        if (playButton) playButton.textContent = "⏸ Pause";
        playInterval = setInterval(() => {
            const step = 24 * 60 * 60 * 1000 * playSpeed;
            const next = new Date(currentDate.getTime() + step);
            if (next >= maxDate) {
                currentDate = new Date(maxDate);
                if (timeSlider) timeSlider.value = 100;
                filterByDate(currentDate);
                onTick();
                clearInterval(playInterval);
                playInterval = null;
                if (playButton) playButton.textContent = "▶ Play";
                return;
            }
            currentDate = next;
            const percent = (currentDate.getTime() - minDate.getTime()) / (maxDate.getTime() - minDate.getTime()) * 100;
            if (timeSlider) timeSlider.value = percent;
            filterByDate(currentDate);
            onTick();
        }, 120);
    }

    function stopPlay() {
        if (!playInterval) return;
        clearInterval(playInterval);
        playInterval = null;
        if (playButton) playButton.textContent = "▶ Play";
    }

    function togglePlay() {
        if (playInterval) stopPlay();
        else startPlay();
    }

    if (playButton) playButton.addEventListener('click', togglePlay);
    if (resetButton) resetButton.addEventListener('click', () => {
        stopPlay();
        currentDate = new Date(minDate);
        if (timeSlider) timeSlider.value = 0;
        filterByDate(currentDate);
        onTick();
    });

    speedOptions.forEach(opt => {
        opt.addEventListener('click', function() {
            speedOptions.forEach(o => o.classList.remove('active'));
            this.classList.add('active');
            playSpeed = parseFloat(this.dataset.speed || '1');
            if (playInterval) {
                stopPlay();
                startPlay();
            }
        });
    });

    // initialize (set date, compute counters, initial visibility)
    currentDate = new Date(minDate);
    if (timeSlider) timeSlider.value = 0;
    filterByDate(currentDate);
    updateTimeDisplay();

    // expose setter
    window.__setVisualizationDatePercent = setCurrentDateFromSliderValue;
} // end initVisualization

document.addEventListener('DOMContentLoaded', initVisualization);
</script>


</html>
